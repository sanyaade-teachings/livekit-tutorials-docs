{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LiveKit tutorials","text":"<p>This site contains simple, functional and comprehensible guided tutorials for LiveKit applications. They all offer basically the same functionality, but built with different platforms in the client side and the server side, all compatible with each other. Just choose the ones that better fit your needs.</p> <p>You can use them purely for didactic purposes, but also as a solid starting point to build your own application.</p>"},{"location":"#what-is-livekit","title":"What is LiveKit?","text":"<p>LiveKit is an open source, cutting edge, end-to-end WebRTC stack with which you can build ultra-low latency real-time audio and video applications. It offers the latest technologies in terms of real-time media, and a fantastic collection of SDKs for both your application's server and client.</p> <p>With the power of LiveKit you can add video conferencing capabilities to your platform, build the next big live streaming application or even add AI processing to your media flow (such as AI conversational agents or computer-vision recognition). The possibilities are truly endless!</p>"},{"location":"#architecture-of-a-livekit-application","title":"Architecture of a Livekit application","text":"Architecture of a LiveKit application <p>Any LiveKit application has 3 different parts:</p> <ul> <li>Your LiveKit Server: provides all the necessary infrastructure for streaming real-time audio and video. It can usually be treated as a black box in which its internal aspects are not important: you just deploy it and connect your application to it.</li> <li>Your Application Client: runs in your user devices and interacts with the LiveKit deployment through any LiveKit Client SDK. Your users will join rooms as participants to send and receive real-time audio and video tracks. It needs a token generated by the Application Server to join a room. Here you can find examples of Application Clients in different frontend languages: Application Clients.</li> <li>Your Application Server: interacts with the LiveKit deployment through any LiveKit Server SDK. At a minimum, it is responsible for the generation of tokens for the Application Client to join a room. But you can implement your own business logic managing rooms, participants and tracks from the safety of your Application Server. Here you can find examples of Application Servers in different backend languages: Application Servers.</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":""},{"location":"#application-client-tutorials","title":"Application client tutorials","text":"<p>Every application client below shares the same core functionality:</p> <ul> <li>Users request a LiveKit token to any application server to connect to a room.</li> <li>Users may publish their camera, microphone and screen-share.</li> <li>Users automatically subscribe to all media published by other users.</li> <li>Users may leave the room at any time.   </li> </ul> <p>Every application client below is interchangeable with the others, because:</p> <ul> <li>All of them are compatible with each other, meaning that participants are able to join the same LiveKit room from any of the client applications.</li> <li>All of them are compatible with any application server, meaning that they can request a LiveKit token from any of the server applications.</li> </ul> <p> JavaScript</p> <p> React</p> <p> Angular</p> <p> Vue</p> <p> Electron</p> <p> Ionic</p> <p> Android</p> <p> iOS</p>"},{"location":"#application-server-tutorials","title":"Application server tutorials","text":"<p>Every application server below has two specific purposes:</p> <ul> <li>Generate LiveKit tokens on demand for any application client.</li> <li>Receive LiveKit webhook events.</li> </ul> <p>To do so they all define two REST endpoints:</p> <ul> <li><code>/token</code>: takes a room and participant name and returns a token.</li> <li><code>/webhook</code>: for receiving webhook events from LiveKit Server.</li> </ul> <p>They use the proper LiveKit Server SDK for their language, if available.</p> <p> Node.js</p> <p> Go</p> <p> Ruby</p> <p> Java</p> <p> Python</p> <p> Rust</p> <p> PHP</p> <p> .NET</p>"},{"location":"#advanced-features-tutorials","title":"Advanced features tutorials","text":"<p>Explore more advanced features of LiveKit! For now, we have implemented a basic recording tutorial and an advanced one, but our tutorials for streaming and ingesting are coming soon.</p> <p> Recording Basic</p> <p> Recording Advanced</p>"},{"location":"#about-the-authors-of-this-site","title":"About the authors of this site","text":"<p>This site has been created and is maintained by the OpenVidu team. OpenVidu developers have been working with real-time media for over a decade. We first developed Kurento as a powerful media server with low-level capabilities, and then built OpenVidu as a higher-level platform to simplify the development of real-time applications.</p> <p> </p> <p> </p> <p>As the years went by, we continued to improve OpenVidu, making it more efficient, more versatile and more feature-rich. We finally made the decision to embrace mediasoup as the internal engine of the platform. mediasoup is an open source SFU designed down to the last detail to deliver the highest possible performance. We love this project: we are very close to it and have collaborated on it on several occasions.</p> <p>We have helped thousands of developers, companies and organizations to build their real-time applications. Over the years we have seen a myriad of successful use cases built on top of OpenVidu: e-learning, telemedicine, video conferencing, live streaming, proctoring, real-time surveillance, remote assistance... The list goes on and on.</p> <p>We are now bringing our expertise to LiveKit, and integrating its amazing WebRTC stack directly into OpenVidu.</p> <p>Check out section What is OpenVidu? to learn more about how OpenVidu can help you take your LiveKit applications to the next level.</p> <p></p>"},{"location":"about-openvidu/","title":"What is OpenVidu?","text":"<p>OpenVidu is a powerful platform to develop WebRTC real-time applications. With it you can add real-time audio and video capabilities to your application: build any kind of videoconference experience, serve ultra-low latency livestreams to thousands of users, manage real-time videos from your drones or camera feeds and record them... The possibilities are truly endless!</p> <p>It is based on LiveKit and mediasoup, bringing the best of both worlds to provide a performant, fault-tolerant, scalable and observable solution.</p> LiveKit Logo and based <p> OpenVidu is built upon  LiveKit and mediasoup , the best open source, cutting edge, end-to-end WebRTC stacks. OpenVidu takes the best of LiveKit and the best of mediasoup and mix them together in the ultimate real-time solution.</p> server On-Premises <p> OpenVidu is provided as a software that you install on your own servers. You can easily deploy and manage a fully fledged live-video solution in your own infrastructure, including the most popular cloud providers.</p> lightning-bolt Performant <p> OpenVidu is built to be incredibly powerful. It uses LiveKit at its core, but it goes much further providing up to 2x performance of LiveKit. You can host double the users in your video rooms just by using OpenVidu. </p> chart-timeline-variant-shimmer Scalable <p> OpenVidu has been designed from the outset with scalability in mind. Add nodes to increase the capacity of your cluster when necessary and remove them when no longer needed to optimize your resources. </p> shield-refresh Fault Tolerant <p> OpenVidu offers fault tolerance in all its components. Deploy a reliable cluster knowing that if one of your node goes down, others will be able to continue working with no downtime. </p> microscope Observable <p> OpenVidu provides different tools and APIs to monitor the status, health, performance and history of your deployment. It automatically collects logs and metrics and offers a dashboard to visualize them. </p>"},{"location":"about-openvidu/#openvidu-editions","title":"OpenVidu editions","text":"<p>OpenVidu is available in two editions:</p> <ul> <li>OpenVidu COMMUNITY: free to use. It is a single-server deployment and provides a custom LiveKit distribution with Egress, Ingress, S3 storage and monitoring. Ideal for development and testing, but also for small-scale production deployments. You can host hundreds of simultaneous participants in your rooms by running OpenVidu Community in a sufficiently powerful server!</li> <li>OpenVidu PRO: OpenVidu commercial edition. It is a multi-server deployment with all the features of OpenVidu Community plus 2x performance, scalability, fault tolerance and improved monitoring and observability. Ideal for large-scale production deployments with heavy traffic that require the highest standards. You can start with OpenVidu Community and upgrade to OpenVidu Pro when needed.</li> </ul> <p>Visit openvidu.io to learn more about what OpenVidu has to offer.</p> <p></p>"},{"location":"openvidu-vs-livekit/","title":"Running OpenVidu vs LiveKit locally","text":"<p>If you want to run the tutorials on this site locally without the need to create an account on LiveKit Cloud, we recommend running OpenVidu locally. OpenVidu is 100% compatible with LiveKit, and it offers many advantages for local development:</p> <ul> <li>Egress and Ingress services already integrated with a Redis instance. See more.</li> <li>S3 compatible storage for Egress recordings. See more.</li> <li>Administration dashboard to monitor your Rooms. See more.</li> <li>OpenVidu Call: a ready-to-use app. See more.</li> <li>Access your application from any device in your local network. See more.</li> </ul> <p>Whenever you are ready to deploy your real-time application, OpenVidu for production brings awesome features. Visit What is OpenVidu? to learn more.</p> Run OpenVidu locally <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol>"},{"location":"openvidu-vs-livekit/#egress-and-ingress-out-of-the-box","title":"Egress and Ingress out of the box","text":"<p>LiveKit allows you to export media from a Room (for example recording it) or import media into a Room (for example ingesting a video file), using Egress and Ingress services respectively. These modules are independent of LiveKit Server and must be correctly configured and connected via a shared Redis.</p> <p>When running OpenVidu locally you will have all these services properly integrated, so you can focus on developing your app without worrying about anything else.</p>"},{"location":"openvidu-vs-livekit/#s3-compatible-storage","title":"S3 compatible storage","text":"<p>If you are planning to make use of the Egress service to export media out of your Rooms, you will need an S3 compatible bucket to store the generated files, and configure your LiveKit deployment to use it.</p> <p>When running OpenVidu locally you will have an S3 compatible storage available right away (MinIO).</p>"},{"location":"openvidu-vs-livekit/#administration-dashboard","title":"Administration dashboard","text":"<p>OpenVidu comes with an administration dashboard that allows you to monitor the status of your Rooms. Not only in real time, but also historically: the number of participants, the number of published tracks, Egress and Ingress processes... This is a great tool to have when developing your app, as it can help spotting issues and debugging your application's logic.</p>"},{"location":"openvidu-vs-livekit/#openvidu-call","title":"OpenVidu Call","text":"<p>When running OpenVidu locally a default application will be available for you to try. We have named this application OpenVidu Call, and it gathers the most important features that advanced videonconference apps would require: camera selection, screen sharing, virtual backgrounds, chat, recording...</p> <p>You can use OpenVidu Call to help develop your own application, joining participants to shared rooms between your app and OpenVidu Call, and seeing how your app behaves.</p>"},{"location":"openvidu-vs-livekit/#accessing-your-app-from-other-devices-in-your-network","title":"Accessing your app from other devices in your network","text":"<p>Testing WebRTC applications can be challenging because devices require a secure context (HTTPS) to access the camera and microphone. When using LiveKit Open Source, this isn't an issue if you access your app from the same computer where the LiveKit Server is running, as <code>localhost</code> is considered a secure context even over plain HTTP. Consider the following architecture:</p> <p>The simplest way to test your application is:</p> <ol> <li>Run LiveKit Server on your computer.</li> <li>Connect your app to LiveKit Server through <code>localhost</code>.</li> <li>Serve both your application client and server from the same computer.</li> <li>Access your app from <code>localhost</code> in a browser on the same computer.</li> </ol> <p>This setup is straightforward, but what if you need to test your app from multiple devices simultaneously, including real mobile devices? In this case, you must use a secure context (HTTPS), which introduces two challenges:</p> <ol> <li>LiveKit Server open source does not natively support HTTPS. You'll need a reverse proxy to serve LiveKit Server over HTTPS.</li> <li>Even with HTTPS, your SSL certificate might not be valid for local network addresses. You'll need to accept it in the browser for web apps, and install it on mobile devices.</li> </ol> <p>OpenVidu Local Deployment addresses these issues by providing a magic domain name <code>openvidu-local.dev</code> that resolves to any IP specified as a subdomain and provides a valid wildcard certificate for HTTPS. This is similar to services like nip.io, traefik.me, or localtls.</p> <p>When using OpenVidu Local Deployment, you can access OpenVidu Server (which is 100% LiveKit compatible) and your app from any device on your local network with a valid HTTPS certificate. The following table shows the URLs to access the deployment and your application locally and from other devices on your network:</p> Local access Access from devices in your local network Usage Access only from the development machine Access from any device connected to your local network. In the URLs below, replace <code>xxx-yyy-zzz-www</code> with the local IP address of the development machine, replacing the dots (<code>.</code>) with dashes (<code>-</code>). You can find the configured local IP in the <code>.env</code> file in the <code>LAN_PRIVATE_IP</code> variable Application Client (frontend) http://localhost:5080 https://xxx-yyy-zzz-www.openvidu-local.dev:5443 Application Server (backend) http://localhost:6080 https://xxx-yyy-zzz-www.openvidu-local.dev:6443 OpenVidu (LiveKit Compatible) URL http://localhost:7880 https://xxx-yyy-zzz-www.openvidu-local.dev:7443 <p>Info</p> <ul> <li>If you are developing locally, use <code>localhost</code> to access the services, but if you want to test your application from other devices on your network, use the <code>openvidu-local.dev</code> URLs.</li> <li>Replace <code>xxx-yyy-zzz-www</code> with your local IP address. You can find it in the <code>.env</code> file in the <code>LAN_PRIVATE_IP</code> variable.</li> </ul> <p>Warning</p> <p>If the URL isn't working because the IP address is incorrect or the installation script couldn't detect it automatically, you can update the <code>LAN_PRIVATE_IP</code> value in the <code>.env</code> file and restart the deployment with <code>docker compose up</code>.</p> <p>When developing web applications with this deployment, you can use the following code snippet to dynamically determine the appropriate URLs for the application server and the LiveKit server based on the browser's current location. This approach allows you to seamlessly run your application on both your development machine and other devices within your local network without needing to manually adjust the URLs in your code.</p> <pre><code>if (window.location.hostname === \"localhost\") {\n  APPLICATION_SERVER_URL = \"http://localhost:6080\";\n  LIVEKIT_URL = \"ws://localhost:7880\";\n} else {\n  APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443\";\n  LIVEKIT_URL = \"wss://\" + window.location.hostname + \":7443\";\n}\n</code></pre>"},{"location":"openvidu-vs-livekit/#about-openvidu-localdev-domain-and-ssl-certificates","title":"About <code>openvidu-local.dev</code> domain and SSL certificates","text":"<p>This setup simplifies the configuration of local OpenVidu deployments with SSL, making it easier to develop and test your applications securely on your local network by using the <code>openvidu-local.dev</code> domain and a wildcard SSL certificate valid for <code>*.openvidu-local.dev</code>. However, it\u2019s important to note that these certificates are publicly available and do not provide an SSL certificate for production use.</p> <p>The HTTPS offered by <code>openvidu-local.dev</code> is intended for development or testing purposes with the only goal of making your local devices trust your application (which is mandatory in WebRTC applications). For any other use case, it should be treated with the same security considerations as plain HTTP.</p> <p>For production deployments, you should follow the official OpenVidu installation guide.</p>"},{"location":"conditions/cookie-policy/","title":"Cookie Policy","text":""},{"location":"conditions/cookie-policy/#what-are-cookies","title":"What are cookies?","text":"<p>TIKAL TECHNOLOGIES SL web page uses cookies, which are small files that it exchanges with the visitor's web browser for different purposes. That is done in a totally \"invisible\" and harmless way for the visitor, so your visit to the page is more fluid and you are not interrupted by some functions. The following explains which is the usage of cookies in TIKAL TECHNOLOGIES SL website and how you can disable them if you don't agree.</p>"},{"location":"conditions/cookie-policy/#what-kind-of-information-do-we-collect","title":"What kind of information do we collect?","text":"<p>TIKAL TECHNOLOGIES SL web page uses cookies for the following purposes</p> <ul> <li>Functional cookies: they are used to improve the visitor's navigation through the website, making it more user-friendly. It is important to understand that cookies do not contain any kind of specific personal information, and most of them are deleted from the hard disk at the end of the browser session.</li> <li>Analytical Cookies: TIKAL TECHNOLOGIES SL website uses cookies from Google Analytics, to analyze how visitors use the page. This way, TIKAL TECHNOLOGIES SL can offer improvements in the usability of the webpage. Google Analytics only collects and processes anonymous data through the TIKAL TECHNOLOGIES SL website. There is further information about the management of Google Analytics' web analysis services at www.google.com/analytics.</li> </ul>"},{"location":"conditions/cookie-policy/#how-are-users-able-to-change-the-cookies-configuration-in-their-browsers","title":"How are users able to change the cookies configuration in their browsers?","text":"<p>Any browser allows you to make adjustments on the actions to perform whenever a website asks you to store a cookie. You can:</p> <ul> <li>Allow web pages to deposit cookies in the browser.</li> <li>Allow the cookies of the visited web pages only to remain in the browser as long as the page remains open.</li> <li>Do not allow web pages to deposit cookies in the browser. Please note that in this case, some website functions will not be operational or the full page could even not work at all.</li> <li>Allow one by one which web pages will be able to deposit cookies in the browser. Please note that in unauthorized pages some website functions will not be operational or the full page could even not work at all.</li> </ul> <p>The modification of the cookies configuration can be done in the option \"Configuration\" of the browser, in the \"Privacy\" section.</p>"},{"location":"conditions/privacy-policy/","title":"Privacy Policy","text":"<p>In accordance with the provisions of Regulation (EU) 2016/679 and the Organic Law 3/2018 of 5 December, on the protection of personal data and guarantee of digital rights, we inform you that the data you provide will be incorporated to the treatment system owned by TIKAL TECHNOLOGIES SL with CIF B85986669 and address at Calle Chile, N\u00ba 10, 28290 - Las Rozas de Madrid (Madrid), for the purpose of ELECTRONIC COMMERCE, CUSTOMER MANAGEMENT, AND OTHER PURPOSES. Your data may be processed by third parties (they will be data processors recipients of your data for contractual purposes for example, our computer maintenance company) requiring the same level of established rights, obligations and responsibilities. Your details will be kept for the time only strictly necessary. They will be deleted when a period of time has elapsed without any use being made of it. You agree to notify us of any changes in the data. You will be able to exercise your access rights, rectification, limitation of treatment, deletion, portability and opposition to processing of your personal data by addressing your request to the management or to the e-mail info@naevatec.com. You can contact the appropriate supervisory authority to make any complaint you may consider necessary.</p>"},{"location":"conditions/terms-of-service/","title":"Terms of Service","text":"<p>The purpose of the following terms and conditions is to explain our obligations as providers of the service, as well as your obligations as a client. Please read them carefully. </p> <p>The aforementioned terms and conditions shall be applied from the moment TIKAL TECHNOLOGIES provides you with access to the service, thus it is understood that you have voluntarily accepted them as part of the contractual obligations between the parties involved, that is, between TIKAL TECHNOLOGIES (TIKAL form now on) and you as client. OpenVidu PRO is a service which will vary with time, so as to adapt to its clients and users\u00b4 new requirements, which in turn, will likely affect the terms and conditions so that they suit the changes and variations made to TIKAL. </p> <p>TIKAL reserves the right to change the terms and conditions at any given moment, notwithstanding, it shall always endeavour to communicate these via e-mail or through the application itself; consequently, we strongly advise you to ensure that you have read and understood the terms and conditions whose most recent, updated version, is available on our website.</p>"},{"location":"conditions/terms-of-service/#first-definitions","title":"First. Definitions.","text":"<p>For the legal purposes of this contract, the following definitions will apply:</p> <ol> <li>Software application: a set of instructions which will be interpreted, utilized and executed by a computer system. Even when there may be many of them, the present contract may refer to them in singular, and likewise when pertaining to its backup files.</li> <li>Telematics application: a software application within a server which is connected to the Internet such that it can be accessed remotely through electronic networks. The assignment of the license to use the telematics application OpenVidu PRO is the subject of the present contract.</li> <li>Client of the telematics application: the natural or legal person who benefits from the licence to use the telematics application, thus assuming all obligations arising from the present contract.</li> <li>User of the telematics application: the natural person authorized by the client to use the telematics application, who in turn assumes all obligations arising from the present contract and said utilization.</li> <li>Parties: TIKAL and the client.</li> <li>Exploitation rights over the telematics application: TIKAL TECHNOLOGIES SL</li> <li>Third parties: any natural or legal person alien to the present contractual relation, who, for any reason, enters into a formal, legally binding agreement with either TIKAL or the client.</li> <li>The service, all supporting infrastructure provided by TIKAL that allows the client to register, download, provision bill, and operate its instance of the telematics application</li> <li>Hardware: electronic, mechanic or magnetic devices necessary for the telematics application, and its complementary parts, to work properly.</li> <li>Personal data: any information regarding an identified or identifiable natural person.</li> <li>Updates: new versions of the telematics application and/or its modules, which include new functionalities and improvements when compared to earlier versions.</li> <li>Telematics application modules: parts of the telematics application which manage specific functionalities, and whose licence to use them, the client must acquire separately.</li> </ol>"},{"location":"conditions/terms-of-service/#second-purpose","title":"Second. Purpose","text":"<ol> <li>The purpose of the present contract is the licensing of the right to use the telematics application OpenVidu PRO by TIKAL TECHNOLOGIES SL. to the client, so that it may be use in the management of their business. Subject to the terms and conditions provided in this agreement, TIKAL hereby grants to the client a non-exclusive, non-sublicensable, non-transferable license to use the telematics application OpenVidu PRO (from now on \u201ctelematics application\u201d). Under no circumstances however, does said licence grant the client sales rights over the telematics application whose ownership remains entirely with TIKAL TECHNOLOGIES SL.</li> <li>The client\u00b4s rights to use the telematics application are subjected and limited by both the duration, and the terms and conditions established in the present contract.</li> <li>Hereby the client agrees to use the telematics application in compliance with the law, the present contract, and the good and rational will inherently present in any civilized society.</li> <li>The client acknowledges having examined that OpenVidu PRO features fulfil their needs, and that it has been appropriately informed by TIKAL about them.</li> </ol>"},{"location":"conditions/terms-of-service/#third-use-limitations-and-duty-of-care","title":"Third. Use limitations and duty of care.","text":"<ol> <li>The client must protect and guard the telematics application; thus, it may not share any information whatsoever with third parties. It is specifically forbidden the use of the telematics application outside the business sphere for which it has been acquired, or outside any of the dispositions stipulated in this contract. The client may not sell, lease, transfer, or otherwise sublicense the telematics application or take part in any act which may result in the violation of their duty of care and protection. The client may not assign, transfer, pledge or make any other disposition of the rights acquired through this contract, of any part of the contract, or of any of the rights, claims or obligations under the contract.</li> <li>The client is obligated to refrain from using the telematics application for illegal purposes or any other purposes contrary to what is established in the present contract, or any action that may be injurious to TIKAL\u00b4s rights and interests, to the owner of the telematics application, as well as to any third parties involved. Said actions include, but are not limited to, any deed that may harm, overload, disrupt, or otherwise render useless the telematics application, thus preventing other clients and users from making use of it.</li> <li>Changes to the telematics application are strictly forbidden. These include, but are not limited to, such things as reverse engineering, decompiling, disassembling, reproducing, translating, modifying, commercializing, cloning, transforming or transmitting to any natural or legal person, partially or entirely, by any means, whether mechanic, magnetic, photocopies, etc\u2026 or to eliminate or block any proprietary notice or logos pertaining to the telematics application. The components and elements subject to the aforementioned restrictions include, but are not limited to, such things as the logical diagrams, source codes, object and/or data model; except prior, written authorization from TIKAL. These restrictions stand, even when said actions where needed for the interoperability with other computer programs or telematics applications.</li> <li>The client or the user must protect and safeguard, both physically and intellectually, the telematics application, namely, its contents, logical procedures, and access protocols, by establishing the necessary means in order to guarantee the non-disclosure, cloning, reproduction, altering, translation, transformation, access by third parties, or any other action that shall imply a violation of the duty of care or of any intellectual and industrial property right.</li> <li>The telematics application may only be used by the client or authorized user, for processing the client\u00b4s own data and their products, but under no circumstances shall it be used to process third parties \u2018data.</li> <li>TIKAL cannot guarantee uninterrupted access to the service throughout the entire validity period of this contract due to unforeseeable factors such as network issues, telecommunications service providers, breakdown in computers, as well as other contingencies such as repair and maintenance work, and software updates. Notwithstanding this, TIKAL reserves the right to adopt any necessary measures to limit the service, should it be considered that improper and/or irresponsible use of the telematics application is occurring, specially when said uses run counter to the terms and conditions provided in the present contract.</li> <li>Should the client or user breach the terms of contract, in a continuous and sustained fashion, or acting in bad faith, TIKAL shall terminate the provision of the service, without reimbursing any amount, on the grounds of abusive and improper use.</li> <li>Interpretation and scope. Any other right which has not been stated or directly mentioned in the present contract, remains reserved to TIKAL. Under no circumstances shall the terms and conditions of this contract be interpreted or applied in such a fashion that could be injurious to TIKAL or in any manner that runs counter to the regular exploitation framework of a telematics application.</li> </ol>"},{"location":"conditions/terms-of-service/#fourth-liability","title":"Fourth. Liability.","text":"<ol> <li>TIKAL\u00b4s telematics application is access-ready in its current state and configuration. Should the application contain any deficiency attributable to TIKAL TECHNOLOGIES SL, the latter pledges to make use of all the resources available to them in order to solve the issue as promptly as possible. Nonetheless, it declines any liability and does not give any guarantee regarding violations perpetrated by third parties, marketability, satisfactory quality or suitability for a specific purpose.</li> <li>TIKAL shall act with due diligence and professionalism by making use of all its resources available so as to ensure the quality, reliability, and security of the telematics application. In any case, TIKAL\u00b4s assumes no liability for any damages, direct or indirect, incidental or special, including, but not limited to, such things as damages or financial loss, work disruptions, failure, breakdown, or any losses, even when the possibility of such inconveniences occurring, which include third-party complaints, were previously notified to a member of TIKAL\u00b4s staff.</li> <li>The client accepts, within reason, to tolerate specific, isolated disruptions in connectivity and hereby forfeits the right to claim any liability, contractual or otherwise, as well as damages owing to possible failures, slowness or access errors. TIKAL declines any liability concerning data loss, accidental or otherwise, resulting from the client\u00b4s actions or activities.</li> <li>The client or user is solely responsible for the provision and payment of the costs necessary to ensure compatibility between the telematics application and their equipment, including all hardware, software, electronic components, and any other component required to access the telematics application, these include, but are not limited to, such things as telecommunication services, Internet access and connectivity, operating systems, or any other program, equipment or services, required to access and use the telematics application.</li> <li>TIKAL declines any liability regarding any content that the client or user may host within the telematics application OpenVidu PRO, since at no moment, does TIKAL intervene in the internal processing of said content. Therefore, and in accordance with art.16 of LSSI-CE, TIKAL is not legally bound to remove any content from the server, provided there is no \u201cactual knowledge\u201d that the activity or information stored is illegal, libellous, or injurious to third-party rights or assets. In this regard, it shall be understood that \u201cactual knowledge\u201d exits, when there is a court or administrative decision, ordering to block or remove content and that the contractor (TIKAL) has been made aware of it. Notwithstanding, TIKAL reserves the right to remove this type of content out of its own volition, once it has been detected, whilst the client waives any right to claim or demand compensation. Should the application be in any way damaged due to the introduction of malign software or content (virus, trojan,\u2026) TIKAL reserves the right to automatically terminate the contract without having to pay any compensation whatsoever. On the other hand, TIKAL hereby reserves the right to demand compensation from the client or user for any damages caused to the system.</li> <li>The client or user shall burden all legal costs incurred when the cause is attributable to them, these include TIKAL lawyers\u2019 fees, even when a final court decision has yet to be reached.</li> <li>TIKAL uses information security protocols which are broadly accepted and observed by the industry such as firewalls, access-control procedures, and crypto mechanisms in order to avoid any unauthorized access to the data. For this purpose, the client hereby grants TIKAL access to data so that it can perform access-control authentication. The licensing process or any process which entails the introduction of personal data shall always conducted under a rigorous communication protocol so as to ensure no third parties have access to data transmitted electronically.</li> </ol>"},{"location":"conditions/terms-of-service/#fifth-intellectual-and-industrial-property-rights","title":"Fifth. Intellectual and industrial property rights.","text":"<ol> <li>The exploitation rights of the telematics application are owned by TIKAL and protected by Spanish Intellectual Property Laws applicable in any country where it is used. The structure, organization and coding of the telematics application constitute confidential and valuable industrial and commercial secrets which belong to TIKAL. Therefore, the client must treat the telematics application in the same fashion they would when utilizing any material protected by intellectual property rights, thus copying, duplicating, or cloning the application is strictly forbidden.</li> <li>The present licence to use the telematics application does not imply, either explicitly or implicitly, the assignment of the intellectual and industrial rights over said application, the hardware, or the data model.</li> <li>Brands must be utilized in accordance with the commercial uses of brands, including acknowledging the proprietor\u2019s name of the brand. Brands may only be used in order identify those printouts produced by the telematics application. Said utilization does not imply or grant any property rights over the application.</li> <li>The knowledge and expertise intrinsic to the telematics application, as well as the knowledge utilized to configure it, is confidential information which belongs to the owner of the telematics application TIKAL. The client acknowledges this and assumes all liability regarding fraudulent use, or illegal copy or duplication of said application, or complementary programs, or utilization of this information by third parties, being liable for any breach of the present contract, by them or by any person or persons depending or associated with the client, or when these individuals have been granted access, directly or indirectly, to the telematics application by the client.</li> <li>Updates: For the entire validity period of the present contract, and in accordance with the terms and conditions stipulated in the next paragraph, the client is entitled to have access to the updates of the telematics application as they arise. The client assumes all legal liability for the updates, regarding limitations and duty of care, in the same fashion as with the original computer application. Updates to additional modules of the telematics application shall be given to those clients who have acquired from TIKAL the licence to use said modules.</li> <li>Hereby the client gives TIKAL consent to incorporate them as such into their business portfolio, thus allowing TIKAL to use their brand and logo on its website as well as in documents which may be given to other potential clients, for the sole purpose of said portfolio, and provided that the client does not express opposition to them being used in such a fashion.</li> </ol>"},{"location":"conditions/terms-of-service/#sixth-right-to-amend","title":"Sixth. Right to amend.","text":"<p>TIKAL reserves the right to update the telematics application to the latest version available on the market. Said updates may include, but are not limited to, such things as new functionalities, improvements, and modifications and legal updates to the telematics application, which may vary, at any moment such things as its features, performance, and configuration of the telematics application content. </p> <p>TIKAL pledges to evaluate and take into consideration suggestions and requests made by clients and users of the telematics application so that they may be incorporated in the new versions of said application; however, it is TIKAL\u00b4s right, not the client\u00b4s to decide which modifications or improvements may be included in the aforementioned versions. </p> <p>TIKAL reserves the right to modify, at any moment, the characteristics, features, and conditions of TIKAL for the benefit and development of the service. With this in mind, TIKAL may only have to observe the formality of having to notify the client via an on-line notice, or by modifying any clause in this contract. Notwithstanding the foregoing, TIKAL shall endeavour to promptly notify the client so that the latter may adapt them.</p>"},{"location":"conditions/terms-of-service/#seventh-exclusion-and-termination-of-licensing","title":"Seventh. Exclusion and termination of licensing.","text":"<ol> <li>TIKAL reserves the right to exclude and/or terminate, temporarily or in a definite manner, the client\u00b4s right to use the telematics application, in case the following occurring:<ul> <li>Breach of any of the terms and conditions of the present contract.</li> <li>Breach of law and order and/or improper, illegal, or negligent professional behavior.</li> <li>When a court, administrative, or official decision is made to do so.</li> </ul> </li> <li>The exclusion clause, or termination of this contract, does not imply that TIKAL forfeits the right to take legal actions or file for financial compensation when the client has acted in bad faith to damage, directly or indirectly, the telematics application.</li> </ol>"},{"location":"conditions/terms-of-service/#eighth-communications","title":"Eighth. Communications.","text":"<ol> <li>For the purposes of establishing a line of communication regarding the present contract both parties agree to use the place of residence which appears in it. The client pledges to keep the e-mail account provided in this licensing agreement, operational, activated and updated for the purposes of communications with TIKAL, which constitutes TIKAL\u00b4s preferred line of communication (albeit not the only one). In general terms, the client pledges to keep their personal details updated, and must communicate TIKAL, in a clear, unambiguous manner, of any changes.</li> <li>Should the client fail to notify said changes, notifications or notices delivered to the address(es) given by the client in the licensing agreement, shall be considered valid.</li> <li>The client consents that telephone conversations with TIKAL may be recorded with the intent to improve the quality and security of the service.</li> </ol>"},{"location":"conditions/terms-of-service/#ninth-duration","title":"Ninth. Duration.","text":"<ol> <li>The contract shall be valid indefinitely from the moment the client requests it. The client can also put the end to the contract at any time he wishes, being obliged to pay the pending consumed service.</li> <li>As long as the period contract holds it is understood that the validity of the contract published on TIKAL\u00b4s website and containing all updates, prevails.</li> </ol>"},{"location":"conditions/terms-of-service/#tenth-terms-of-payment","title":"Tenth. Terms of payment.","text":"<ol> <li>The price, payment method, billing and payment of the telematics application licensing, object of the present contract, is stipulated in the Current Official Rates Section published on TIKAL\u00b4s website (https://openvidu.io at the time of writing), which are considered part of a whole to all intents and purposes.</li> <li>The price stipulated in the aforementioned Current Official Rates Section, do not include valued added tax (VAT), nor does it include any other taxes or fees established by law whose current rates shall be applied for the provision of the service when signing the present contract. Therefore, said amounts may be increased according to current tax rates.</li> <li>Payment will be done monthly and will cover the whole amount of the service consumed during last month period according to the currently published rates from TIKAL.</li> <li>Monthly payments include both the basic rate for the provision of the service, and the corresponding rate(s) for any optional or additional service hired.</li> <li>Payments must be made effective by the credit or debit card that the client has agreed with TIKAL when first hiring the service. Visa and MasterCard shall be the accepted cards.</li> <li>Total or partial delay in payment by the client for the amount(s) TIKAL has billed them shall grant TIKAL the right to cancel or terminate all contracted obligations in accordance with the present contract. Suspension of the service provision shall be realized within the next fifteen natural days after the contract has reached its expiry date, prior notice to the client. After said fifteen natural days from the day the service was suspended, and prior notification to the client, TIKAL may terminate the contract. If the client pays the full amount owed to TIKAL during said period, the latter shall re-establish the service as promptly as possible from the moment it is notified that the debt has been settled. Notwithstanding the foregoing, TIKAL reserves the right to ask for a two-month deposit as a guarantee before re-establishing the service. The client accepts all liability for any legal costs incurred due to claims made by TIKAL regarding breach of payment after the contract has reached its expiry date, including, but not limited to, such things as the return of invoices and late-payment interest.      When the client returns, for any cause alien to TIKAL, two or more direct-debit invoices, TIKAL shall be entitled to unilaterally opt for the annual hiring and billing of the service.</li> <li>When the client has defaulted on a payment, either totally or partially, during three months, for the amount owed to TIKAL, the latter has the right to rescind the contract between the two parties, as well as the direct and definite termination and cancellation of the service hired by the client, including the database linked to the client\u00b4s services, without prior notice from TIKAL.</li> <li>TIKAL shall apply upon its rates any current deals and offers existing at the time the client hires the service, provided they comply with the terms and conditions of said deals and offers so that they may benefit from them. The client acknowledges and accepts the fact they may obtain detailed information, at any given time, regarding said deals and offers on TIKAL\u00b4s website or through the habitual communication channels with which TIKAL provides its clients.</li> </ol>"},{"location":"conditions/terms-of-service/#eleventh-data-protection","title":"Eleventh. Data Protection.","text":"<p>The parties involved agree that they know, comply with, and are subject to, the Spanish and European laws and legislation regarding Personal Data Protection, thus they must give proper use and treatment to all data arising from any activity subjected to the terms and conditions of this contract.</p>"},{"location":"conditions/terms-of-service/#data-controller-agreement-between-the-client-and-tikal","title":"Data Controller agreement between the client and TIKAL.","text":"<p>In accordance with the Spanish Data Protection Laws, TIKAL\u00b4s access to the client\u00b4s personal files shall not be considered a violation of said laws, insofar as TIKAL is effectively the Data Controller and said access is necessary for the provision of the service which is the subject of this contract. </p> <p>In this regard, and for the purposes of Data Protection regulation, TIKAL shall be regarded as the \u201cData Controller\u201d of the client\u00b4s data. Notwithstanding the foregoing, TIKAL pledges that it shall treat said data in conformity with the client\u00b4s instructions provided in this contract, and that under no circumstances shall it utilise them for any other purposes outside of what the parties have agreed in this contract, nor shall it transfer or communicate them to a third party, not even for back-up or storage purposes. At the same time, the duration and validity of this agreement shall correspond to the type of service hired by the client. </p> <p>Once the provision of said service terminates and the data shall no longer be necessary to perform the aforementioned Data Controller role, all personal data shall be either destroyed or returned to the person, persons or entity responsible for it, as well as any storage medium, documents or files containing personal data. </p> <p>In order to provide the service and what said provision entails, TIKAL shall be granted access to the following information:</p> <ol> <li>Contact details</li> <li>Company profile data</li> <li>Assets and billed services data</li> <li>Tax identification data</li> </ol> <p>TIKAL\u00b4s obligations as Data Controller are described as follows:</p> <ol> <li>Treat all data in accordance with the instructions received by the person, persons or entity in charge of its treatment and only for the purposes provided in this contract.</li> <li>To not communicate or transfer any data to third parties, except prior consent by the body in charge of its treatment, or in cases provided for by the law.</li> <li>TIKAL may not outsource, either totally or partially, the provision of the service(s) described in the present contract, except prior authorization from the client whom shall be informed with due notice about the outsourcing entity as well as the services being outsourced. In this case, TIKAL shall draft and execute a new contract with said outsourcing entity, always in accordance with the current Data Protection laws.</li> <li>To not disclose any personal data to which TIKAL may have had access, even after the termination of this contract.</li> <li>To guarantee that the staff managing personal data pledge to keep the confidentiality which said data entails and that they comply with the proper security protocols.</li> <li>To assist the person or body responsible for data treatment regarding data protection.</li> <li>To provide the person or body responsible for data protection with support and assistance when performing an impact assessment, or when consulting the regulatory authorities, if applicable. Additionally, to provide said person or body with the necessary information so that it may prove their compliance with the rules and regulations.</li> <li>Notwithstanding the foregoing, said person or body has mechanisms in place so as to guarantee the confidentiality, integrity, and availability of the systems and services concerning data protection, as well as to restore the access and availability to data in case of system failure. Additionally, it is endowed with capabilities so as to regularly verify and assess the efficacy of the security protocol.</li> </ol> <p>Duties of the responsible for data treatment:</p> <ol> <li>To guarantee, at all times, compliance with the Data Protection Laws.</li> <li>Make all necessary enquiries beforehand.</li> <li>To supervise that proper data treatment is occurring.</li> <li>To provide the data controller with all necessary data for the provision of the service.</li> </ol> <p>TIKAL\u00b4s duties as Data Controller:</p> <ol> <li>To guarantee, at all times, compliance with the Data Protection Laws.</li> <li>Make all necessary enquiries beforehand.</li> <li>To supervise that proper data treatment is occurring.</li> <li>To provide the data controller with all necessary data for the provision of the service.</li> </ol>"},{"location":"conditions/terms-of-service/#twelfth-confidentiality","title":"Twelfth. Confidentiality.","text":"<ol> <li>All data and information transmitted between the parties is strictly confidential and property of TIKAL and the client, and its protection is of the utmost importance. To this intent, both parties hereby contract the obligation to safeguard said data and information by adopting all appropriate measures to ensure that only authorized individuals shall have access to it; authorized individuals being understood as those employees which are needed by the parties involved so as to keep the provision of the service, which is the object of this contract, in good working order.</li> <li>In this regard, the signatory parties are hereby subject to the following confidential agreement:<ul> <li>Hereby TIKAL pledges to keep confidential all data and information supplied by, and concerning the client, as well as the output arisen from the service provided. In this regard, TIKAL possesses strict internal controls whose objective and end are to guarantee the integrity of the present confidential agreement.</li> <li>The client therefore agrees to keep confidential all data and information arising from TIKAL\u00b4s internal processes, specially the existence, utilization, and functionalities of any process used in the provision of the service.</li> <li>The present confidential agreement shall remain valid even after the termination of the present contractual relation and extends indefinitely to all members of staff that have been granted access to said confidential information.</li> </ul> </li> </ol>"},{"location":"conditions/terms-of-service/#thirteenth-termination-rescission-nullity","title":"Thirteenth. Termination. Rescission. Nullity.","text":"<ol> <li>The present contract shall be considered void for infringement, committed by any of the parties involved, of the Spanish Civil Code, and in particular, of the Spanish Commercial Code, and the obligations arising from the following:<ul> <li>Mutual consent of the parties involved.</li> <li>When the present contract has reached its expiry date which is specified in clause tenth, or within the subsequent extensions thereof.</li> <li>By unilateral rescission provided that the party wishing to rescind communicates this at least one month in advance.</li> <li>When any of the parties has been officially put into administration, has filed for bankruptcy protection, is under bankruptcy or insolvency proceedings, or is under liquidation or dissolution.</li> <li>Due to any other reason(s) provided for in law.</li> <li>Should any of the parties involved breach the contracted obligations provided in the present contract, the other party may consider it as void. Said consideration warrants no prior notice or compensation of any kind, but for the need to communicate the decision to the other party; unless the unaccrued obligations owed by the party are performed within the next fifteen days, counting from the moment said party was notified that they are in breach of the contract . Notwithstanding the foregoing, the other party reserves the right to claim or file for damages caused by this infringement.</li> </ul> </li> <li>TIKAL pledges to destroy all data provided by the client once the contractual relation is extinguished. Likewise, TIKAL shall destroy or return any document or storage medium containing any IT-related data arising from said contractual relation. Once said contractual relation terminates, the client may request TIKAL to supply them with a hard, back-up copy of all data pertaining to and arising from said relation, to any address the client wishes, prior to a written request to do so, which must be sent within the week after the end of the contract. The client shall burden the costs incurred arising from the handling and mailing of said request.</li> <li>The client may cease or cancel the use of the telematics application whenever they wish to do so. Should the client or any authorized user by them request the cancellation of the service at TIKAL\u00b4s offices, it shall become effective on the same day said request was made. Therefore, it is advised to carefully observe said process to avoid any resources or data loss that the client or user may have in their TIKAL\u00b4s account. Should it not be possible for them to initiate said cancellation process at TIKAL\u00b4s offices, the client may request it by contacting TIKAL\u00b4s customer service via any of the channels provided in this contract. Said cancellation shall become effective on the day stipulated by the client, provided that the request has been made with enough time to be processed correctly.</li> </ol>"},{"location":"conditions/terms-of-service/#fourteenth-applicable-legislation-and-jurisdiction","title":"Fourteenth. Applicable legislation and jurisdiction.","text":"<p>The present is a business contract regulated by Spanish laws. The parties involved agree that any discrepancy, legal or civil action, claim or complain arising from the interpretation and execution of the present contract, shall be, directly or indirectly, taken to the Court of Madrid, thus all parties involved hereby renounce to take any matters pertaining to this agreement to any other jurisdiction. </p> <p>The present document constitutes the total agreement of the parties in relation to the matters covered in this agreement, thus substitutes all previous obligations, liabilities, and agreements, both written and verbal, existing prior to the signature and execution of this contract. </p> <p>The following website (www.naevatec.com) belongs to: TIKAL TECHNOLOGIES SL TAX ID: B85986669 10 Chile Rd/St 28290 \u2013 Las Rozas de Madrid (Madrid City) Spain. Registered in the Madrid\u00b4s Trade Register, volume/tome 28043. Book 0 Section 8th of the Registry Book, Page 37, Sheet M-505315.</p>"},{"location":"tutorials/advanced-features/","title":"Advanced Features Tutorials","text":"<p>Explore more advanced features of LiveKit! For now, we have implemented a basic recording tutorial and an advanced one, but our tutorials for streaming and ingesting are coming soon.</p> <p> Recording Basic</p> <p> Recording Advanced</p>"},{"location":"tutorials/advanced-features/recording-advanced/","title":"Advanced Recording Tutorial","text":"<p>Source code </p> <p>This tutorial improves the basic recording tutorial by doing the following:</p> <ul> <li>Complete recording metadata: Listen to webhook events and save all necessary metadata in a separate file.</li> <li>Real time recording status notification: Implement a custom notification system to inform participants about the recording status by listening to webhook events and updating room metadata.</li> <li>Recording deletion notification: Implement a custom notification system that alerts all participants of a recording's deletion by sending data messages.</li> <li>Direct access to recording files: Add an additional method to allow access to recording files directly from the S3 bucket by creating a presigned URL.</li> </ul>"},{"location":"tutorials/advanced-features/recording-advanced/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/advanced-features/recording-advanced/#1-run-livekit-server-and-egress","title":"1. Run LiveKit Server and Egress","text":"<p>You can run LiveKit and Egress locally or you can use their free tier of LiveKit Cloud, which already includes both services.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>This tutorial have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit and Egress locally.</p> <p>Configure Webhooks</p> <p>This tutorial have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>This tutorial have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/advanced-features/recording-advanced/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/advanced-features/recording-advanced/#3-run-the-application","title":"3. Run the application","text":"<p>To run this application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the application directory</li> </ol> <pre><code>cd openvidu-livekit-tutorials/advanced-features/openvidu-recording-advanced-node\n</code></pre> <ol> <li>Install dependencies</li> </ol> <pre><code>npm install\n</code></pre> <ol> <li>Run the application</li> </ol> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:6080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:6443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Limitation: Playing recordings with the <code>S3</code> strategy from other devices in your local network is not possible due to MinIO not being exposed. To play recordings from other devices, you need to change the environment variable <code>RECORDING_PLAYBACK_STRATEGY</code> to <code>PROXY</code>.</p>"},{"location":"tutorials/advanced-features/recording-advanced/#enhancements","title":"Enhancements","text":""},{"location":"tutorials/advanced-features/recording-advanced/#refactoring-backend","title":"Refactoring backend","text":"<p>The backend has been refactored to prevent code duplication and improve readability. The main changes are:</p> <ul> <li> <p>Endpoints have been moved to the <code>controllers</code> folder, creating a controller for each set of related endpoints:</p> <ul> <li><code>RoomController</code> for the room creation endpoint.</li> <li><code>RecordingController</code> for the recording endpoints.</li> <li><code>WebhookController</code> for the webhook endpoint.</li> </ul> </li> <li> <p>The <code>index.js</code> file now simply sets the route for each controller:</p> index.js<pre><code>app.use(\"/token\", roomController);\napp.use(\"/recordings\", recordingController);\napp.use(\"/livekit/webhook\", webhookController);\n</code></pre> </li> <li> <p>The configuration of environment variables and constants has been moved to the <code>config.js</code> file:</p> config.js<pre><code>export const SERVER_PORT = process.env.SERVER_PORT || 6080;\nexport const APP_NAME = \"openvidu-recording-advanced-node\";\n\n// LiveKit configuration\nexport const LIVEKIT_URL = process.env.LIVEKIT_URL || \"http://localhost:7880\";\nexport const LIVEKIT_API_KEY = process.env.LIVEKIT_API_KEY || \"devkey\";\nexport const LIVEKIT_API_SECRET = process.env.LIVEKIT_API_SECRET || \"secret\";\n\n// S3 configuration\nexport const S3_ENDPOINT = process.env.S3_ENDPOINT || \"http://localhost:9000\";\nexport const S3_ACCESS_KEY = process.env.S3_ACCESS_KEY || \"minioadmin\";\nexport const S3_SECRET_KEY = process.env.S3_SECRET_KEY || \"minioadmin\";\nexport const AWS_REGION = process.env.AWS_REGION || \"us-east-1\";\nexport const S3_BUCKET = process.env.S3_BUCKET || \"openvidu\";\n\nexport const RECORDINGS_PATH = process.env.RECORDINGS_PATH ?? \"recordings/\";\nexport const RECORDINGS_METADATA_PATH = \".metadata/\";\nexport const RECORDING_PLAYBACK_STRATEGY = process.env.RECORDING_PLAYBACK_STRATEGY || \"S3\"; // PROXY or S3\nexport const RECORDING_FILE_PORTION_SIZE = 5 * 1024 * 1024; // 5MB\n</code></pre> </li> <li> <p>Operations of the <code>EgressClient</code> and functions related to recording management have been moved to the <code>RecordingService</code> class within the <code>services</code> folder.</p> </li> </ul> <p>After refactoring and implementing the improvements, the backend of the application has the following structure:</p> <pre><code>src\n\u251c\u2500\u2500 controllers\n\u2502   \u251c\u2500\u2500 recording.controller.js\n\u2502   \u251c\u2500\u2500 room.controller.js\n\u2502   \u2514\u2500\u2500 webhook.controller.js\n\u251c\u2500\u2500 services\n\u2502   \u251c\u2500\u2500 recording.service.js\n\u2502   \u251c\u2500\u2500 room.service.js\n\u2502   \u2514\u2500\u2500 s3.service.js\n\u251c\u2500\u2500 config.js\n\u251c\u2500\u2500 index.js\n</code></pre> <p>Where <code>room.service.js</code> defines the <code>RoomService</code> class, that contains the logic to manage rooms using the <code>RoomServiceClient</code>.</p>"},{"location":"tutorials/advanced-features/recording-advanced/#adding-room-metadata","title":"Adding room metadata","text":"<p>In order to store the recording status in the room metadata, we have to create the room explicitly the first time a user joins it, setting the metadata field with an object that contains the recording status. This object also contains the app name, which is used to identify webhook events related to the application. This is done in the <code>POST /token</code> endpoint:</p> room.controller.js<pre><code>roomController.post(\"/\", async (req, res) =&gt; {\n    const roomName = req.body.roomName;\n    const participantName = req.body.participantName;\n\n    if (!roomName || !participantName) {\n        res.status(400).json({ errorMessage: \"roomName and participantName are required\" });\n        return;\n    }\n\n    const at = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET, {\n        identity: participantName\n    });\n    at.addGrant({ room: roomName, roomJoin: true, roomRecord: true });\n    const token = await at.toJwt();\n\n    try {\n        // Create room if it doesn't exist\n        const exists = await roomService.exists(roomName); // (1)!\n\n        if (!exists) {\n            await roomService.createRoom(roomName); // (2)!\n        }\n\n        res.json({ token });\n    } catch (error) {\n        console.error(\"Error creating room.\", error);\n        res.status(500).json({ errorMessage: \"Error creating room\" });\n    }\n});\n</code></pre> <ol> <li>Check if the room exists.</li> <li>Create the room if it doesn't exist.</li> </ol> <p>After generating the access token with the required permissions, this endpoint does the following:</p> <ol> <li> <p>Checks if the room exists by calling the <code>exists</code> method of the <code>RoomService</code> with the <code>roomName</code> as a parameter. This method returns a boolean indicating whether the room obtained from the <code>getRoom</code> method is not <code>null</code>. This other method lists all active rooms that match the <code>roomName</code> by calling the <code>listRooms</code> method of the <code>RoomServiceClient</code> with an array containing the <code>roomName</code> as a parameter, and returns the first element of the list if it exists:</p> room.service.js<pre><code>async getRoom(roomName) {\n    const rooms = await this.roomClient.listRooms([roomName]); // (1)!\n    return rooms.length &gt; 0 ? rooms[0] : null; // (2)!\n}\n\nasync exists(roomName) {\n    const room = await this.getRoom(roomName);\n    return room !== null;\n}\n</code></pre> <ol> <li>List all active rooms that match the <code>roomName</code> by calling the <code>listRooms</code> method of the <code>RoomServiceClient</code> with an array containing the <code>roomName</code> as a parameter.</li> <li>Return the first element of the list if it exists.</li> </ol> </li> <li> <p>Creates the room if it doesn't exist by calling the <code>createRoom</code> method of the <code>RoomService</code> with the <code>roomName</code> as a parameter. This method creates a room with the <code>roomName</code> and sets the metadata field with an object that contains the app name (defined in the <code>config.js</code> file) and the recording status initialized to <code>STOPPED</code>. To achieve this, the method calls the <code>createRoom</code> method of the <code>RoomServiceClient</code> with an object indicating the room name and metadata:</p> room.service.js<pre><code>async createRoom(roomName) {\n    const roomOptions = {\n        name: roomName,\n        metadata: JSON.stringify({\n            createdBy: APP_NAME, // (1)!\n            recordingStatus: \"STOPPED\" // (2)!\n        })\n    };\n    return this.roomClient.createRoom(roomOptions); // (3)!\n}\n</code></pre> <ol> <li>Set the app name.</li> <li>Set the recording status to <code>STOPPED</code>.</li> <li>Create the room with the <code>roomOptions</code> object by calling the <code>createRoom</code> method of the <code>RoomServiceClient</code>.</li> </ol> </li> </ol>"},{"location":"tutorials/advanced-features/recording-advanced/#handling-webhook-events","title":"Handling webhook events","text":"<p>In previous tutorials, we listened to all webhook events and printed them in the console without doing anything else. In this tutorial, we have to first check if the webhook is related to the application and then act accordingly depending on the event type. This is done in the <code>POST /livekit/webhook</code> endpoint:</p> webhook.controller.js<pre><code>webhookController.post(\"/\", async (req, res) =&gt; {\n    try {\n        const webhookEvent = await webhookReceiver.receive(req.body, req.get(\"Authorization\"));\n        const isWebhookRelatedToMe = await checkWebhookRelatedToMe(webhookEvent); // (1)!\n\n        if (isWebhookRelatedToMe) {\n            console.log(webhookEvent);\n            const { event: eventType, egressInfo } = webhookEvent; // (2)!\n\n            switch (eventType) {\n                case \"egress_started\": // (3)!\n                case \"egress_updated\":\n                    await notifyRecordingStatusUpdate(egressInfo);\n                    break;\n                case \"egress_ended\": // (4)!\n                    await handleEgressEnded(egressInfo);\n                    break;\n            }\n        }\n    } catch (error) {\n        console.error(\"Error validating webhook event.\", error);\n    }\n\n    res.status(200).send();\n});\n</code></pre> <ol> <li>Check if the webhook is related to the application.</li> <li>Destructure the event type and egress info from the webhook event.</li> <li>If the event type is <code>egress_started</code> or <code>egress_updated</code>, notify the recording status update.</li> <li>If the event type is <code>egress_ended</code>, handle the egress ended.</li> </ol> <p>After receiving the webhook event, this endpoint does the following:</p> <ol> <li> <p>Checks if the webhook is related to the application by calling the <code>checkWebhookRelatedToMe</code> function with the webhook event as a parameter. This function returns a boolean indicating whether the app name obtained from the metadata field of the room related to the webhook event is equal to the app name defined in the <code>config.js</code> file:</p> webhook.controller.js<pre><code>const checkWebhookRelatedToMe = async (webhookEvent) =&gt; {\n    const { room, egressInfo, ingressInfo } = webhookEvent; // (1)!\n    let roomInfo = room;\n    // (2)!\n    if (!room || !room.metadata) {\n        const roomName = room?.name ?? egressInfo?.roomName ?? ingressInfo?.roomName; // (3)!\n        roomInfo = await roomService.getRoom(roomName); // (4)!\n\n        if (!roomInfo) {\n            return false;\n        }\n    }\n\n    const metadata = roomInfo.metadata ? JSON.parse(roomInfo.metadata) : null; // (5)!\n    return metadata?.createdBy === APP_NAME; // (6)!\n};\n</code></pre> <ol> <li>Destructure the room, egress info, and ingress info from the webhook event.</li> <li>Check if the room and metadata fields exist.</li> <li>If the room or metadata fields don't exist, get the room name from the room, egress info, or ingress info.</li> <li>Get the room info by calling the <code>getRoom</code> method of the <code>RoomService</code> with the <code>roomName</code> as a parameter.</li> <li>Parse the metadata field of the room info.</li> <li>Return whether the app name is equal to the app name defined in the <code>config.js</code> file.</li> </ol> </li> <li> <p>Destructures the event type and egress info from the webhook event.</p> </li> <li> <p>If the event type is <code>egress_started</code> or <code>egress_updated</code>, calls the <code>notifyRecordingStatusUpdate</code> function with the egress info as a parameter. This function notifies all participants in the room related to the egress info about the recording status update. See the Notifying recording status update section for more information.</p> </li> <li> <p>If the event type is <code>egress_ended</code>, calls the <code>handleEgressEnded</code> function with the egress info as a parameter. This function saves the recording metadata in a separate file (see the Saving recording metadata section) and notifies all participants in the room related to the egress info that the recording has been stopped:</p> webhook.controller.js<pre><code>const handleEgressEnded = async (egressInfo) =&gt; {\n    try {\n        await recordingService.saveRecordingMetadata(egressInfo); // (1)!\n    } catch (error) {\n        console.error(\"Error saving recording metadata.\", error);\n    }\n\n    await notifyRecordingStatusUpdate(egressInfo); // (2)!\n};\n</code></pre> <ol> <li>Save the recording metadata.</li> <li>Notify all participants in the room that the recording has been stopped.</li> </ol> </li> </ol>"},{"location":"tutorials/advanced-features/recording-advanced/#notifying-recording-status-update","title":"Notifying recording status update","text":"<p>When the recording status changes, all participants in the room have to be notified. This is done by updating the metadata field of the room with the new recording status, which will trigger the <code>RoomEvent.RoomMetadataChanged</code> event in the client side. This is implemented in the <code>notifyRecordingStatusUpdate</code> function:</p> webhook.controller.js<pre><code>const notifyRecordingStatusUpdate = async (egressInfo) =&gt; {\n    const roomName = egressInfo.roomName; // (1)!\n    const recordingStatus = recordingService.getRecordingStatus(egressInfo.status); // (2)!\n\n    try {\n        await roomService.updateRoomMetadata(roomName, recordingStatus); // (3)!\n    } catch (error) {\n        console.error(\"Error updating room metadata.\", error);\n    }\n};\n</code></pre> <ol> <li>Get the room name from the egress info.</li> <li>Get the recording status from the egress info status.</li> <li>Update the room metadata with the new recording status.</li> </ol> <p>After getting the room name from the egress info, this function does the following:</p> <ol> <li> <p>Gets the recording status by calling the <code>getRecordingStatus</code> method of the <code>RecordingService</code> with the egress info status as a parameter. This method returns the recording status based on the egress info status:</p> recording.service.js<pre><code>getRecordingStatus(egressStatus) {\n    switch (egressStatus) {\n        case EgressStatus.EGRESS_STARTING:\n            return \"STARTING\";\n        case EgressStatus.EGRESS_ACTIVE:\n            return \"STARTED\";\n        case EgressStatus.EGRESS_ENDING:\n            return \"STOPPING\";\n        case EgressStatus.EGRESS_COMPLETE:\n            return \"STOPPED\";\n        default:\n            return \"FAILED\";\n    }\n}\n</code></pre> <p>We distinguish between the following recording statuses:</p> <ul> <li><code>STARTING</code>: The recording is starting.</li> <li><code>STARTED</code>: The recording is active.</li> <li><code>STOPPING</code>: The recording is stopping.</li> <li><code>STOPPED</code>: The recording has stopped.</li> <li><code>FAILED</code>: The recording has failed.</li> </ul> </li> <li> <p>Updates the room metadata with the new recording status by calling the <code>updateRoomMetadata</code> method of the <code>RoomService</code> with the <code>roomName</code> and <code>recordingStatus</code> as parameters. This method updates the metadata field of the room with an object that contains the app name and the new recording status by calling the <code>updateRoomMetadata</code> method of the <code>RoomServiceClient</code> with the <code>roomName</code> and a stringified object as parameters:</p> room.service.js<pre><code>async updateRoomMetadata(roomName, recordingStatus) {\n    const metadata = {\n        createdBy: APP_NAME,\n        recordingStatus // (1)!\n    };\n    return this.roomClient.updateRoomMetadata(roomName, JSON.stringify(metadata)); // (2)!\n}\n</code></pre> <ol> <li>Update the recording status.</li> <li>Update the room metadata with the new metadata by calling the <code>updateRoomMetadata</code> method of the <code>RoomServiceClient</code> with the <code>roomName</code> and a stringified object as parameters.</li> </ol> </li> </ol>"},{"location":"tutorials/advanced-features/recording-advanced/#saving-recording-metadata","title":"Saving recording metadata","text":"<p>When the recording ends, the metadata related to the recording has to be saved in a separate file. This is done in the <code>saveRecordingMetadata</code> function:</p> recording.service.js<pre><code>async saveRecordingMetadata(egressInfo) {\n    const recordingInfo = this.convertToRecordingInfo(egressInfo); // (1)!\n    const key = this.getMetadataKey(recordingInfo.name); // (2)!\n    await s3Service.uploadObject(key, recordingInfo); // (3)!\n}\n</code></pre> <ol> <li>Convert the egress info to a recording info object.</li> <li>Get the metadata key from the recording info name.</li> <li>Upload the recording metadata to the S3 bucket.</li> </ol> <p>This method does the following:</p> <ol> <li> <p>Converts the egress info to a recording info object by calling the <code>convertToRecordingInfo</code> method:</p> recording.service.js<pre><code>convertToRecordingInfo(egressInfo) {\n    const file = egressInfo.fileResults[0];\n    return {\n        id: egressInfo.egressId,\n        name: file.filename.split(\"/\").pop(),\n        roomName: egressInfo.roomName,\n        roomId: egressInfo.roomId,\n        startedAt: Number(egressInfo.startedAt) / 1_000_000,\n        duration: Number(file.duration) / 1_000_000_000,\n        size: Number(file.size)\n    };\n}\n</code></pre> <p>Getting recording metadata</p> <p>In this tutorial, we can access detailed information about the recording directly from the metadata file stored in the S3 bucket, without needing to make additional requests. This is made possible by saving all the necessary data retrieved from the egress info object. Compared to the basic recording tutorial, we are now storing additional details such as the recording name, duration and size.</p> </li> <li> <p>Gets the metadata key from the recordings path and the recordings metadata path, both defined in the <code>config.js</code> file, and the recording name replacing the <code>.mp4</code> extension with <code>.json</code>:</p> recording.service.js<pre><code>getMetadataKey(recordingName) {\n    return RECORDINGS_PATH + RECORDINGS_METADATA_PATH + recordingName.replace(\".mp4\", \".json\");\n}\n</code></pre> </li> <li> <p>Uploads the recording metadata to the S3 bucket by calling the <code>uploadObject</code> method of the <code>S3Service</code> with the <code>key</code> and <code>recordingInfo</code> as parameters. This method uploads an object to the S3 bucket by sending a <code>PutObjectCommand</code> with the key and the stringified object as parameters:</p> s3.service.js<pre><code>async uploadObject(key, body) {\n    const params = {\n        Bucket: S3_BUCKET,\n        Key: key,\n        Body: JSON.stringify(body)\n    };\n    const command = new PutObjectCommand(params);\n    return this.run(command);\n}\n</code></pre> </li> </ol>"},{"location":"tutorials/advanced-features/recording-advanced/#notifying-recording-deletion","title":"Notifying recording deletion","text":"<p>When a recording is deleted, all participants in the room have to be notified. This is done by sending a data message to all participants in the room. To achieve this, the <code>DELETE /recordings/:recordingName</code> endpoint has been modified as follows:</p> recording.controller.js<pre><code>recordingController.delete(\"/:recordingName\", async (req, res) =&gt; {\n    const { recordingName } = req.params;\n    const exists = await recordingService.existsRecording(recordingName);\n\n    if (!exists) {\n        res.status(404).json({ errorMessage: \"Recording not found\" });\n        return;\n    }\n\n    try {\n        const { roomName } = await recordingService.getRecordingMetadata(recordingName); // (1)!\n        await recordingService.deleteRecording(recordingName);\n\n        // Notify to all participants that the recording was deleted\n        const existsRoom = await roomService.exists(roomName); // (2)!\n\n        if (existsRoom) {\n            await roomService.sendDataToRoom(roomName, { recordingName }); // (3)!\n        }\n\n        res.json({ message: \"Recording deleted\" });\n    } catch (error) {\n        console.error(\"Error deleting recording.\", error);\n        res.status(500).json({ errorMessage: \"Error deleting recording\" });\n    }\n});\n</code></pre> <ol> <li>Get the room name from the recording metadata.</li> <li>Check if the room exists.</li> <li>Send a data message to the room indicating that the recording was deleted.</li> </ol> <p>Before deleting the recording, we get the room name from the recording metadata. After deleting the recording, we check if the room exists and, if it does, send a data message to the room indicating that the recording was deleted. This is done by calling the <code>sendDataToRoom</code> method of the <code>RoomService</code> with the <code>roomName</code> and an object containing the <code>recordingName</code> as parameters:</p> room.service.js<pre><code>async sendDataToRoom(roomName, rawData) {\n    const data = encoder.encode(JSON.stringify(rawData)); // (1)!\n    const options = {\n        topic: \"RECORDING_DELETED\", // (2)!\n        destinationSids: [] // (3)!\n    };\n\n    try {\n        await this.roomClient.sendData(roomName, data, DataPacket_Kind.RELIABLE, options); // (4)!\n    } catch (error) {\n        console.error(\"Error sending data to room\", error);\n    }\n}\n</code></pre> <ol> <li>Encodes the raw data.</li> <li>Sets the topic to <code>RECORDING_DELETED</code>.</li> <li>Sets the destination SIDs to an empty array (all participants in the room).</li> <li>Sends the data message to the room by calling the <code>sendData</code> method of the <code>RoomServiceClient</code> with the <code>roomName</code>, <code>data</code>, <code>DataPacket_Kind.RELIABLE</code> and <code>options</code> as parameters.</li> </ol> <p>This method does the following:</p> <ol> <li>Encodes the raw data by calling the <code>encode</code> method of the <code>TextEncoder</code> with the stringified raw data as a parameter.</li> <li>Sets the topic of the data message to <code>RECORDING_DELETED</code>.</li> <li>Sets the destination SIDs to an empty array, which means that the message will be sent to all participants in the room.</li> <li>Sends the data message to the room by calling the <code>sendData</code> method of the <code>RoomServiceClient</code> with the <code>roomName</code>, <code>data</code>, <code>DataPacket_Kind.RELIABLE</code> and <code>options</code> as parameters. The <code>DataPacket_Kind.RELIABLE</code> parameter indicates that the message will be sent reliably.</li> </ol>"},{"location":"tutorials/advanced-features/recording-advanced/#accessing-recording-files-directly-from-the-s3-bucket","title":"Accessing recording files directly from the S3 bucket","text":"<p>In this tutorial, we have added an additional method to allow access to recording files directly from the S3 bucket by creating a presigned URL. To accomplish this, we have created a new endpoint (<code>GET /recordings/:recordingName/url</code>) to get the recording URL depending on the playback strategy defined in the environment variable <code>RECORDING_PLAYBACK_STRATEGY</code>, whose value can be <code>PROXY</code> or <code>S3</code>:</p> recording.controller.js<pre><code>recordingController.get(\"/:recordingName/url\", async (req, res) =&gt; {\n    const { recordingName } = req.params;\n    const exists = await recordingService.existsRecording(recordingName); // (1)!\n\n    if (!exists) {\n        res.status(404).json({ errorMessage: \"Recording not found\" });\n        return;\n    }\n\n    // If the recording playback strategy is \"PROXY\", return the endpoint URL\n    if (RECORDING_PLAYBACK_STRATEGY === \"PROXY\") {\n        res.json({ recordingUrl: `/recordings/${recordingName}` }); // (2)!\n        return;\n    }\n\n    try {\n        // If the recording playback strategy is \"S3\", return a signed URL to access the recording directly from S3\n        const recordingUrl = await recordingService.getRecordingUrl(recordingName); // (3)!\n        res.json({ recordingUrl });\n    } catch (error) {\n        console.error(\"Error getting recording URL.\", error);\n        res.status(500).json({ errorMessage: \"Error getting recording URL\" });\n    }\n});\n</code></pre> <ol> <li>Check if the recording exists.</li> <li>Return the <code>GET /recordings/:recordingName</code> endpoint URL if the playback strategy is <code>PROXY</code>.</li> <li>Create a presigned URL to access the recording directly from the S3 bucket if the playback strategy is <code>S3</code>.</li> </ol> <p>This endpoint does the following:</p> <ol> <li>Extracts the <code>recordingName</code> parameter from the request.</li> <li>Checks if the recording exists. If it does not exist, it returns a <code>404</code> error.</li> <li>If the playback strategy is <code>PROXY</code>, it returns the <code>GET /recordings/:recordingName</code> endpoint URL to get the recording file from the backend.</li> <li> <p>If the playback strategy is <code>S3</code>, it creates a presigned URL to access the recording directly from the S3 bucket by calling the <code>getRecordingUrl</code> method of the <code>RecordingService</code> with the <code>recordingName</code> as a parameter. This method simply calls the <code>getObjectUrl</code> method of the <code>S3Service</code> with the key of the recording as a parameter:</p> s3.service.js<pre><code>async getObjectUrl(key) {\n    const params = {\n        Bucket: S3_BUCKET,\n        Key: key\n    };\n    const command = new GetObjectCommand(params);\n    return getSignedUrl(this.s3Client, command, { expiresIn: 86400 }); // 24 hours\n}\n</code></pre> <p>This method creates a presigned URL to access the object in the S3 bucket by calling the <code>getSignedUrl</code> function from the @aws-sdk/s3-request-presigner package, indicating the <code>S3Client</code>, <code>GetObjectCommand</code> and the expiration time in seconds as parameters. In this case, the expiration time is set to 24 hours.</p> <p>Presigned URLs</p> <p>Presigned URLs are URLs that provide access to an S3 object for a limited time. This is useful when you want to share an object with someone for a limited time without providing them with your AWS credentials.</p> <p>Compared to the proxy strategy, accessing recording files directly from the S3 bucket via presigned URLs is more efficient, as it reduces server load. However, it presents a security risk, as the URL, once generated, can be used by anyone until it expires.</p> </li> </ol>"},{"location":"tutorials/advanced-features/recording-advanced/#handling-new-room-events-in-the-client-side","title":"Handling new room events in the client side","text":"<p>In the client side, we have to handle the new room events related to the recording status and the recording deletion. This is done by listening to the <code>RoomEvent.RoomMetadataChanged</code> and <code>RoomEvent.DataReceived</code> events in the <code>joinRoom</code> method:</p> app.js<pre><code>async function joinRoom() {\n    // ...\n    // When recording status changes...\n    room.on(LivekitClient.RoomEvent.RoomMetadataChanged, async (metadata) =&gt; {\n        const { recordingStatus } = JSON.parse(metadata);\n        await updateRecordingInfo(recordingStatus);\n    });\n\n    // When a message is received...\n    room.on(LivekitClient.RoomEvent.DataReceived, async (payload, _participant, _kind, topic) =&gt; {\n        // If the message is a recording deletion notification, remove the recording from the list\n        if (topic === \"RECORDING_DELETED\") {\n            const { recordingName } = JSON.parse(new TextDecoder().decode(payload));\n            deleteRecordingContainer(recordingName);\n        }\n    });\n    // ...\n}\n</code></pre> <p>When a new <code>RoomEvent.RoomMetadataChanged</code> event is received, we parse the metadata to get the recording status and update the recording info accordingly. The <code>updateRecordingInfo</code> function has been updated to handle the new recording statuses.</p> <p>In addition to handling this event, we need to update the recording info in the UI the first time a user joins the room. Once the user has joined, we retrieve the current room metadata and update the UI accordingly. Recordings will be listed unless the recording status is <code>STOPPED</code> or <code>FAILED</code>, to prevent listing recordings twice:</p> app.js<pre><code>async function joinRoom() {\n    // ...\n    // Update recording info\n    const { recordingStatus } = JSON.parse(room.metadata);\n    await updateRecordingInfo(recordingStatus);\n\n    if (recordingStatus !== \"STOPPED\" &amp;&amp; recordingStatus !== \"FAILED\") {\n        const roomId = await room.getSid();\n        await listRecordings(room.name, roomId);\n    }\n    // ...\n}\n</code></pre> <p>When a new <code>RoomEvent.DataReceived</code> event is received, we check if the topic of the message is <code>RECORDING_DELETED</code>. If it is, we decode the payload using a <code>TextDecoder</code> and parse the message to get the recording name. Then, we remove the recording from the list by calling the <code>deleteRecordingContainer</code> function.</p>"},{"location":"tutorials/advanced-features/recording-basic/","title":"Basic Recording Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application, built upon Node.js server and JavaScript client tutorials, and extends them by adding recording capabilities:</p> <ul> <li>Start and stop recording a room.</li> <li>List all recordings in a room.</li> <li>Play a recording.</li> <li>Delete a recording.</li> <li>List all available recordings and filter them by room name.</li> </ul>"},{"location":"tutorials/advanced-features/recording-basic/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/advanced-features/recording-basic/#1-run-livekit-server-and-egress","title":"1. Run LiveKit Server and Egress","text":"<p>You can run LiveKit and Egress locally or you can use their free tier of LiveKit Cloud, which already includes both services.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>This tutorial have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit and Egress locally.</p> <p>Configure Webhooks</p> <p>This tutorial have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>This tutorial have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/advanced-features/recording-basic/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/advanced-features/recording-basic/#3-run-the-application","title":"3. Run the application","text":"<p>To run this application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the application directory</li> </ol> <pre><code>cd openvidu-livekit-tutorials/advanced-features/openvidu-recording-basic-node\n</code></pre> <ol> <li>Install dependencies</li> </ol> <pre><code>npm install\n</code></pre> <ol> <li>Run the application</li> </ol> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:6080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:6443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"tutorials/advanced-features/recording-basic/#understanding-the-code","title":"Understanding the code","text":"<p>This application consists of two essential backend files under the <code>src</code> directory:</p> <ul> <li><code>index.js</code>: This file holds the server application and defines the REST API endpoints.</li> <li><code>s3.service.js</code>: This file encapsulates the operations to interact with the S3 bucket.</li> </ul> <p>And the following essential frontend files under the <code>public</code> directory:</p> <ul> <li><code>index.html</code>: This is the client application's main HTML file.</li> <li><code>app.js</code>: This is the main JavaScript file that interacts with the server application and handles the client application's logic and functionality.</li> <li><code>style.css</code>: This file contains the client application's styling.</li> <li><code>recordings.html</code>: This file defines the HTML for the general recording page.</li> </ul>"},{"location":"tutorials/advanced-features/recording-basic/#backend","title":"Backend","text":"<p>The server application extends the Node.js server tutorial by adding the following REST API endpoints:</p> <ul> <li><code>POST /recordings/start</code>: Starts the recording of a room.</li> <li><code>POST /recordings/stop</code>: Stops the recording of a room.</li> <li><code>GET /recordings</code>: Lists all recordings stored in the S3 bucket. This endpoint also allows filtering recordings by room name or room ID.</li> <li><code>GET /recordings/:recordingName</code>: Retrieves a recording from the S3 bucket and returns it as a stream.</li> <li><code>DELETE /recordings/:recordingName</code>: This endpoint deletes a recording from the S3 bucket.</li> </ul> <p>Before we dive into the code of each endpoint, let's first see the changes introduced in the <code>index.js</code> file:</p> index.js<pre><code>const SERVER_PORT = process.env.SERVER_PORT || 6080;\n\n// LiveKit configuration\nconst LIVEKIT_URL = process.env.LIVEKIT_URL || \"http://localhost:7880\"; // (1)!\nconst LIVEKIT_API_KEY = process.env.LIVEKIT_API_KEY || \"devkey\";\nconst LIVEKIT_API_SECRET = process.env.LIVEKIT_API_SECRET || \"secret\";\n\nconst RECORDINGS_PATH = process.env.RECORDINGS_PATH ?? \"recordings/\"; // (2)!\nconst RECORDING_FILE_PORTION_SIZE = 5 * 1024 * 1024; // (3)!\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\napp.use(express.raw({ type: \"application/webhook+json\" }));\n\n// Set the static files location\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\napp.use(express.static(path.join(__dirname, \"../public\"))); // (4)!\n</code></pre> <ol> <li>The URL of the LiveKit server.</li> <li>The path where recordings will be stored in the S3 bucket.</li> <li>The portion size of the recording that will be sent to the client in each request. This value is set to <code>5 MB</code>.</li> <li>Set the <code>public</code> directory as the static files location.</li> </ol> <p>There are three new environment variables:</p> <ul> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server.</li> <li><code>RECORDINGS_PATH</code>: The path where recordings will be stored in the S3 bucket.</li> <li><code>RECORDING_FILE_PORTION_SIZE</code>: The portion size of the recording that will be sent to the client in each request.</li> </ul> <p>Besides, the <code>index.js</code> file configures the server to serve static files from the <code>public</code> directory.</p> <p>It also initializes the <code>EgressClient</code>, which will help interacting with Egress API to manage recordings, and the <code>S3Service</code>, which will help interacting with the S3 bucket:</p> index.js<pre><code>const egressClient = new EgressClient(LIVEKIT_URL, LIVEKIT_API_KEY, LIVEKIT_API_SECRET);\nconst s3Service = new S3Service();\n</code></pre> <p>The <code>POST /token</code> endpoint has been modified to add the <code>roomRecord</code> permission to the access token, so that participants can start recording a room:</p> index.js<pre><code>app.post(\"/token\", async (req, res) =&gt; {\n    const roomName = req.body.roomName;\n    const participantName = req.body.participantName;\n\n    if (!roomName || !participantName) {\n        res.status(400).json({ errorMessage: \"roomName and participantName are required\" });\n        return;\n    }\n\n    const at = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET, {\n        identity: participantName\n    });\n    at.addGrant({ roomJoin: true, room: roomName, roomRecord: true }); // (1)!\n    const token = await at.toJwt();\n    res.json({ token });\n});\n</code></pre> <ol> <li>Add the <code>roomRecord</code> permission to the access token.</li> </ol> <p>Now let's explore the code for each recording feature:</p>"},{"location":"tutorials/advanced-features/recording-basic/#start-recording","title":"Start recording","text":"<p>The <code>POST /recordings/start</code> endpoint starts the recording of a room. It receives the room name of the room to record as parameter and returns the recording metadata:</p> index.js<pre><code>app.post(\"/recordings/start\", async (req, res) =&gt; {\n    const { roomName } = req.body;\n\n    if (!roomName) {\n        res.status(400).json({ errorMessage: \"roomName is required\" });\n        return;\n    }\n\n    const activeRecording = await getActiveRecordingByRoom(roomName); // (1)!\n\n    // Check if there is already an active recording for this room\n    if (activeRecording) {\n        res.status(409).json({ errorMessage: \"Recording already started for this room\" }); // (2)!\n        return;\n    }\n\n    // Use the EncodedFileOutput to save the recording to an MP4 file\n    // (3)!\n    const fileOutput = new EncodedFileOutput({\n        fileType: EncodedFileType.MP4, // (4)!\n        filepath: `${RECORDINGS_PATH}{room_name}-{room_id}-{time}` // (5)!\n    });\n\n    try {\n        // Start a RoomCompositeEgress to record all participants in the room\n        const egressInfo = await egressClient.startRoomCompositeEgress(roomName, { file: fileOutput }); // (6)!\n        const recording = {\n            name: egressInfo.fileResults[0].filename.split(\"/\").pop(), // (7)!\n            startedAt: Number(egressInfo.startedAt) / 1_000_000\n        };\n        res.json({ message: \"Recording started\", recording }); // (8)!\n    } catch (error) {\n        console.error(\"Error starting recording.\", error);\n        res.status(500).json({ errorMessage: \"Error starting recording\" });\n    }\n});\n</code></pre> <ol> <li>The <code>getActiveRecordingByRoom</code> function retrieves the active recording for a room.</li> <li>If there is already an active recording for the room, the server returns a <code>409 Conflict</code> status code.</li> <li>Use the <code>EncodedFileOutput</code> class to export the recording to an external file.</li> <li>Define the file type as <code>MP4</code>.</li> <li>Define the file path where the recording will be stored. The <code>{room_name}</code>, <code>{room_id}</code>, and <code>{time}</code> templates will be replaced by the actual room name, room ID and timestamp, respectively. Check out all available filename templates.</li> <li>Start a <code>RoomCompositeEgress</code> to record all participants in the room by calling the <code>startRoomCompositeEgress</code> method of the <code>EgressClient</code> with the <code>roomName</code> and <code>fileOutput</code> as parameters.</li> <li>Extract the recording name from the <code>fileResults</code> array.</li> <li>Return the recording metadata to the client.</li> </ol> <p>This endpoint does the following:</p> <ol> <li>Obtains the <code>roomName</code> parameter from the request body. If it is not available, it returns a <code>400</code> error.</li> <li> <p>Check if there is already an active recording for the room. If there is, it returns a <code>409</code> error to prevent starting a new recording. To accomplish this, we use the <code>getActiveRecordingByRoom</code> function, which lists all active egresses for a specified room by calling the <code>listEgress</code> method of the <code>EgressClient</code> with the <code>roomName</code> and <code>active</code> parameters, and then returns the egress ID of the first active egress found:</p> index.js<pre><code>const getActiveRecordingByRoom = async (roomName) =&gt; {\n    try {\n        // List all active egresses for the room\n        const egresses = await egressClient.listEgress({ roomName, active: true });\n        return egresses.length &gt; 0 ? egresses[0].egressId : null;\n    } catch (error) {\n        console.error(\"Error listing egresses.\", error);\n        return null;\n    }\n};\n</code></pre> </li> <li> <p>Initializes an <code>EncodedFileOutput</code> object to export the recording to an external file. It sets the file type as <code>MP4</code> and defines the file path where the recording will be stored. The <code>{room_name}</code>, <code>{room_id}</code>, and <code>{time}</code> templates will be replaced by the actual room name, room ID, and timestamp, respectively. Check out all available filename templates.</p> <p>Saving recording metadata</p> <p>The <code>EncodedFileOutput</code> class allows you to save the recording metadata to an external file. If you don't explicitly set the <code>disableManifest</code> property to <code>true</code>, the metadata will be saved in the same folder and with the same name as the recording file, but with a <code>.json</code> extension. This metadata file will contain information such as the egress ID, the recording start time, and the name and ID of the room recorded.</p> <p>This information may be insufficient depending on your requirements (e.g., you can't get the recording duration). If this is the case, you can follow the steps described in the advanced recording tutorial, where we show how to save all necessary metadata in a separate file listening to webhook events.</p> </li> <li> <p>Starts a <code>RoomCompositeEgress</code> to record all participants in the room by calling the <code>startRoomCompositeEgress</code> method of the <code>EgressClient</code> with <code>roomName</code> and <code>fileOutput</code> as parameters.</p> </li> <li>Extracts the recording name from the <code>fileResults</code> array.</li> <li>Returns the recording metadata to the client.</li> </ol>"},{"location":"tutorials/advanced-features/recording-basic/#stop-recording","title":"Stop recording","text":"<p>The <code>POST /recordings/stop</code> endpoint stops the recording of a room. It receives the room name of the room to stop recording as a parameter and returns the updated recording metadata:</p> index.js<pre><code>app.post(\"/recordings/stop\", async (req, res) =&gt; {\n    const { roomName } = req.body;\n\n    if (!roomName) {\n        res.status(400).json({ errorMessage: \"roomName is required\" });\n        return;\n    }\n\n    const activeRecording = await getActiveRecordingByRoom(roomName); // (1)!\n\n    // Check if there is an active recording for this room\n    if (!activeRecording) {\n        res.status(409).json({ errorMessage: \"Recording not started for this room\" }); // (2)!\n        return;\n    }\n\n    try {\n        // Stop the egress to finish the recording\n        const egressInfo = await egressClient.stopEgress(activeRecording); // (3)!\n        const file = egressInfo.fileResults[0];\n        const recording = {\n            name: file.filename.split(\"/\").pop(),\n            startedAt: Number(egressInfo.startedAt) / 1_000_000,\n            size: Number(file.size)\n        };\n        res.json({ message: \"Recording stopped\", recording }); // (4)!\n    } catch (error) {\n        console.error(\"Error stopping recording.\", error);\n        res.status(500).json({ errorMessage: \"Error stopping recording\" });\n    }\n});\n</code></pre> <ol> <li>The <code>getActiveRecordingByRoom</code> function retrieves the active recording for a room.</li> <li>If there is no active recording for the room, the server returns a <code>409 Conflict</code> status code.</li> <li>Stop the egress to finish the recording by calling the <code>stopEgress</code> method of the <code>EgressClient</code> with the egress ID (<code>activeRecording</code>) as a parameter.</li> <li>Return the updated recording metadata to the client.</li> </ol> <p>This endpoint does the following:</p> <ol> <li>Obtains the <code>roomName</code> parameter from the request body. If it is not available, it returns a <code>400</code> error.</li> <li>Retrieves all active egresses for the room. If there is no active egress for the room, it returns a <code>409</code> error to prevent stopping a non-existent recording.</li> <li>Extracts the <code>egressId</code> from the active egress.</li> <li>Stops the egress to finish the recording by calling the <code>stopEgress</code> method of the <code>EgressClient</code> with the egress ID (<code>activeRecording</code>) as a parameter.</li> <li>Returns the updated recording metadata to the client.</li> </ol>"},{"location":"tutorials/advanced-features/recording-basic/#list-recordings","title":"List recordings","text":"<p>The <code>GET /recordings</code> endpoint lists all recordings stored in the S3 bucket. This endpoint also allows filtering recordings by room name or room ID:</p> index.js<pre><code>app.get(\"/recordings\", async (req, res) =&gt; {\n    const roomName = req.query.roomName?.toString();\n    const roomId = req.query.roomId?.toString();\n\n    try {\n        const keyStart = RECORDINGS_PATH + (roomName ? `${roomName}-` + (roomId ? roomId : \"\") : \"\"); // (1)!\n        const keyEnd = \".mp4.json\";\n        const regex = new RegExp(`^${keyStart}.*${keyEnd}$`); // (2)!\n\n        // List all egress metadata files in the recordings path that match the regex\n        const payloadKeys = await s3Service.listObjects(RECORDINGS_PATH, regex); // (3)!\n        const recordings = await Promise.all(payloadKeys.map((payloadKey) =&gt; getRecordingInfo(payloadKey))); // (4)!\n        const sortedRecordings = filterAndSortRecordings(recordings, roomName, roomId); // (5)!\n        res.json({ recordings: sortedRecordings }); // (6)!\n    } catch (error) {\n        console.error(\"Error listing recordings.\", error);\n        res.status(500).json({ errorMessage: \"Error listing recordings\" });\n    }\n});\n</code></pre> <ol> <li>Define the start of the key (path) depending on the <code>roomName</code> and <code>roomId</code> query parameters.</li> <li>Create a regex pattern with the start and end of the key.</li> <li>List all Egress metadata files in the recordings path in the S3 bucket that match the regex.</li> <li>Retrieve the recording metadata for each recording that matches the regex.</li> <li>Filter the recordings by room name and room ID and sort them by start time.</li> <li>Return the list of recordings to the client.</li> </ol> <p>This endpoint does the following:</p> <ol> <li>Extracts the <code>roomName</code> and <code>roomId</code> query parameters from the request.</li> <li>Defines the start of the key (path) depending on the <code>roomName</code> and <code>roomId</code> query parameters.</li> <li>Creates a regex pattern with the start and end of the key.</li> <li>Lists all Egress metadata files in the recordings path in the S3 bucket that match the regex. To accomplish this, we use the <code>listObjects</code> method of the <code>S3Service</code> with the <code>RECORDINGS_PATH</code> and <code>regex</code> as parameters.</li> <li> <p>Retrieves the recording metadata for each recording that matches the regex. To accomplish this, we use the <code>getRecordingInfo</code> function, which retrieves the egress metadata file as JSON and the recording file size by calling the <code>getObjectAsJson</code> and <code>getObjectSize</code> methods of the <code>S3Service</code>, respectively. It then extracts the recording name from the recording key and returns the recording metadata:</p> index.js<pre><code>const getRecordingInfo = async (payloadKey) =&gt; {\n    // Get the egress metadata file as JSON\n    const data = await s3Service.getObjectAsJson(payloadKey); // (1)!\n\n    // Get the recording file size\n    const recordingKey = payloadKey.replace(\".json\", \"\");\n    const size = await s3Service.getObjectSize(recordingKey); // (2)!\n\n    const recordingName = recordingKey.split(\"/\").pop();\n    const recording = {\n        id: data.egress_id,\n        name: recordingName,\n        roomName: data.room_name,\n        roomId: data.room_id,\n        startedAt: Number(data.started_at) / 1000000,\n        size: size\n    };\n    return recording;\n};\n</code></pre> <ol> <li>Get the egress metadata file as JSON.</li> <li>Get the recording file size.</li> </ol> </li> <li> <p>Filter the recordings by room name and room ID and sort them by start time. To accomplish this, we use the <code>filterAndSortRecordings</code> function:</p> index.js<pre><code>const filterAndSortRecordings = (recordings, roomName, roomId) =&gt; {\n    let filteredRecordings = recordings;\n\n    if (roomName || roomId) {\n        filteredRecordings = recordings.filter((recording) =&gt; {\n            return (!roomName || recording.roomName === roomName) &amp;&amp; (!roomId || recording.roomId === roomId); // (1)!\n        });\n    }\n\n    return filteredRecordings.sort((a, b) =&gt; b.startedAt - a.startedAt); // (2)!\n};\n</code></pre> <ol> <li>Filter the recordings by room name and room ID if they are provided.</li> <li>Sort the recordings by start time in descending order.</li> </ol> </li> <li> <p>Returns the list of recordings to the client.</p> </li> </ol>"},{"location":"tutorials/advanced-features/recording-basic/#get-recording","title":"Get recording","text":"<p>The <code>GET /recordings/:recordingName</code> endpoint retrieves a specific portion of a recording from the S3 bucket and returns it as a stream. The server sends the recording file in portions of <code>5 MB</code> each time the client requests a range of the recording file. This is done to prevent loading the entire recording file into memory and to allow the client to play the recording while it is being downloaded and seek to a specific time:</p> index.js<pre><code>app.get(\"/recordings/:recordingName\", async (req, res) =&gt; {\n    const { recordingName } = req.params;\n    const { range } = req.headers;\n    const key = RECORDINGS_PATH + recordingName;\n    const exists = await s3Service.exists(key); // (1)!\n\n    if (!exists) {\n        res.status(404).json({ errorMessage: \"Recording not found\" });\n        return;\n    }\n\n    try {\n        // Get the recording file from S3\n        const { stream, size, start, end } = await getRecordingStream(recordingName, range); // (2)!\n\n        // Set the response headers\n        res.status(206); // (3)!\n        res.setHeader(\"Cache-Control\", \"no-cache\"); // (4)!\n        res.setHeader(\"Content-Type\", \"video/mp4\"); // (5)!\n        res.setHeader(\"Accept-Ranges\", \"bytes\"); // (6)!\n        res.setHeader(\"Content-Range\", `bytes ${start}-${end}/${size}`); // (7)!\n        res.setHeader(\"Content-Length\", end - start + 1); // (8)!\n\n        // Pipe the recording file to the response\n        body.pipe(res).on(\"finish\", () =&gt; res.end()); // (9)!\n    } catch (error) {\n        console.error(\"Error getting recording.\", error);\n        res.status(500).json({ errorMessage: \"Error getting recording\" });\n    }\n});\n</code></pre> <ol> <li>Check if the recording exists in the S3 bucket.</li> <li>Get the recording file from the S3 bucket.</li> <li>Set the response status code to <code>206 Partial Content</code>.</li> <li>Set the <code>Cache-Control</code> header as <code>no-cache</code>.</li> <li>Set the <code>Content-Type</code> header as <code>video/mp4</code>.</li> <li>Set the <code>Accept-Ranges</code> header as <code>bytes</code>.</li> <li>Set the <code>Content-Range</code> header with the start and end of the recording file and its size.</li> <li>Set the <code>Content-Length</code> header as the size of the recording file portion.</li> <li>Pipe the recording file to the response.</li> </ol> <p>This endpoint does the following:</p> <ol> <li>Extracts the <code>recordingName</code> parameter from the request.</li> <li>Checks if the recording exists in the S3 bucket by calling the <code>exists</code> method of the <code>S3Service</code> with the <code>key</code> as a parameter. If the recording does not exist, it returns a <code>404</code> error.</li> <li> <p>Gets the requested range of the recording file by calling the <code>getRecordingStream</code> function:</p> index.js<pre><code>const getRecordingStream = async (recordingName, range) =&gt; {\n    const key = RECORDINGS_PATH + recordingName;\n    const size = await s3Service.getObjectSize(key); // (1)!\n\n    // Get the requested range\n    const parts = range?.replace(/bytes=/, \"\").split(\"-\");\n    const start = range ? parseInt(parts[0], 10) : 0; // (2)!\n    const endRange = parts[1] ? parseInt(parts[1], 10) : start + RECORDING_FILE_PORTION_SIZE; // (3)!\n    const end = Math.min(endRange, size - 1); // (4)!\n\n    const stream = await s3Service.getObject(key, { start, end }); // (5)!\n    return { stream, size, start, end };\n};\n</code></pre> <ol> <li>Get the size of the recording file.</li> <li>Get the start of the requested range.</li> <li>Get the end of the requested range or set it to the start plus the established portion size.</li> <li>Get the minimum between the end of the requested range and the size of the recording file minus one.</li> <li>Get the recording file from the S3 bucket with the requested range.</li> </ol> <p>This function does the following:</p> <ol> <li>Gets the size of the recording file by calling the <code>getObjectSize</code> method of the <code>S3Service</code> with the <code>key</code> as a parameter.</li> <li>Extracts the start of the requested range from the <code>range</code> header.</li> <li>Extracts the end of the requested range from the <code>range</code> header. If the end is not provided, it sets the end to the start plus the established portion size.</li> <li>Gets the minimum between the end of the requested range and the size of the recording file minus one. This is done to prevent requesting a range that exceeds the recording file size.</li> <li>Gets the recording file from the S3 bucket with the requested range by calling the <code>getObject</code> method of the <code>S3Service</code> with the <code>key</code> and <code>range</code> as parameters.</li> </ol> </li> <li> <p>Sets the response headers:</p> <ul> <li><code>Cache-Control</code>: <code>no-cache</code>.</li> <li><code>Content-Type</code>: <code>video/mp4</code>.</li> <li><code>Accept-Ranges</code>: <code>bytes</code>.</li> <li><code>Content-Range</code>: The start and end of the recording file and its size.</li> <li><code>Content-Length</code>: The size of the recording file portion.</li> </ul> </li> <li> <p>Pipes the recording file to the response.</p> </li> </ol> <p>Direct access to S3 bucket</p> <p>With this approach, the backend acts as a proxy between the client and S3, which may result in increased server resource usage. To avoid this, it is more efficient to provide the client with a presigned URL, allowing direct access to the recording files from the S3 bucket. In the advanced recording tutorial, we show how to implement this method, along with a discussion of its advantages and disadvantages.</p>"},{"location":"tutorials/advanced-features/recording-basic/#delete-recording","title":"Delete recording","text":"<p>The <code>DELETE /recordings/:recordingName</code> endpoint deletes a recording from the S3 bucket:</p> index.js<pre><code>app.delete(\"/recordings/:recordingName\", async (req, res) =&gt; {\n    const { recordingName } = req.params;\n    const key = RECORDINGS_PATH + recordingName;\n    const exists = await s3Service.exists(key); // (1)!\n\n    if (!exists) {\n        res.status(404).json({ errorMessage: \"Recording not found\" });\n        return;\n    }\n\n    try {\n        // Delete the recording file and metadata file from S3\n        await Promise.all([s3Service.deleteObject(key), s3Service.deleteObject(`${key}.json`)]); // (2)!\n        res.json({ message: \"Recording deleted\" });\n    } catch (error) {\n        console.error(\"Error deleting recording.\", error);\n        res.status(500).json({ errorMessage: \"Error deleting recording\" });\n    }\n});\n</code></pre> <ol> <li>Check if the recording exists in the S3 bucket.</li> <li>Delete the recording file and metadata file from the S3 bucket.</li> </ol> <p>This endpoint does the following:</p> <ol> <li>Extracts the <code>recordingName</code> parameter from the request.</li> <li>Checks if the recording exists in the S3 bucket by calling the <code>exists</code> method of the <code>S3Service</code> with the <code>key</code> as a parameter. If the recording does not exist, it returns a <code>404</code> error.</li> <li>Deletes the recording file and metadata file from the S3 bucket by calling the <code>deleteObject</code> method of the <code>S3Service</code> with the <code>key</code> and <code>${key}.json</code> as a parameter, respectively.</li> </ol>"},{"location":"tutorials/advanced-features/recording-basic/#s3-service","title":"S3 service","text":"<p>Finally, let's take a look at the <code>s3.service.js</code> file, which encapsulates the operations to interact with the S3 bucket:</p> s3.service.js<pre><code>// S3 configuration\nconst S3_ENDPOINT = process.env.S3_ENDPOINT || \"http://localhost:9000\"; // (1)!\nconst S3_ACCESS_KEY = process.env.S3_ACCESS_KEY || \"minioadmin\"; // (2)!\nconst S3_SECRET_KEY = process.env.S3_SECRET_KEY || \"minioadmin\"; // (3)!\nconst AWS_REGION = process.env.AWS_REGION || \"us-east-1\"; // (4)!\nconst S3_BUCKET = process.env.S3_BUCKET || \"openvidu\"; // (5)!\n\nexport class S3Service {\n    static instance;\n\n    constructor() {\n        if (S3Service.instance) {\n            return S3Service.instance;\n        }\n        // (6)!\n        this.s3Client = new S3Client({\n            endpoint: S3_ENDPOINT,\n            credentials: {\n                accessKeyId: S3_ACCESS_KEY,\n                secretAccessKey: S3_SECRET_KEY\n            },\n            region: AWS_REGION,\n            forcePathStyle: true\n        });\n\n        S3Service.instance = this;\n        return this;\n    }\n    // (7)!\n    async exists(key) {\n        try {\n            await this.headObject(key);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n    // (8)!\n    async headObject(key) {\n        const params = {\n            Bucket: S3_BUCKET,\n            Key: key\n        };\n        const command = new HeadObjectCommand(params);\n        return this.run(command);\n    }\n    // (9)!\n    async getObjectSize(key) {\n        const { ContentLength: size } = await this.headObject(key);\n        return size;\n    }\n    // (10)!\n    async getObject(key, range) {\n        const params = {\n            Bucket: S3_BUCKET,\n            Key: key,\n            Range: range ? `bytes=${range.start}-${range.end}` : undefined\n        };\n        const command = new GetObjectCommand(params);\n        const { Body: body } = await this.run(command);\n        return body;\n    }\n    // (11)!\n    async getObjectAsJson(key) {\n        const body = await this.getObject(key);\n        const stringifiedData = await body.transformToString();\n        return JSON.parse(stringifiedData);\n    }\n    // (12)!\n    async listObjects(prefix, regex) {\n        const params = {\n            Bucket: S3_BUCKET,\n            Prefix: prefix\n        };\n        const command = new ListObjectsV2Command(params);\n        const { Contents: objects } = await this.run(command);\n\n        // Filter objects by regex and return the keys\n        return objects?.filter((object) =&gt; regex.test(object.Key)).map((payload) =&gt; payload.Key) ?? [];\n    }\n    // (13)!\n    async deleteObject(key) {\n        const params = {\n            Bucket: S3_BUCKET,\n            Key: key\n        };\n        const command = new DeleteObjectCommand(params);\n        return this.run(command);\n    }\n    // (14)!\n    async run(command) {\n        return this.s3Client.send(command);\n    }\n}\n</code></pre> <ol> <li>The URL of the S3 server.</li> <li>The access key of the S3 server.</li> <li>The secret key of the S3 server.</li> <li>The AWS region of the S3 server.</li> <li>The name of the S3 bucket.</li> <li>Initialize the <code>S3Client</code> with the provided configuration.</li> <li>Check if an object exists in the S3 bucket.</li> <li>Retrieve the metadata of an object in the S3 bucket.</li> <li>Retrieve the size of an object in the S3 bucket.</li> <li>Retrieve a specified range of bytes from an object in the S3 bucket.</li> <li>Retrieve an object from the S3 bucket as JSON.</li> <li>List objects in the S3 bucket that match a regex pattern.</li> <li>Delete an object from the S3 bucket.</li> <li>Execute an S3 command.</li> </ol> <p>This file loads environment variables for the S3 configuration:</p> <ul> <li><code>S3_ENDPOINT</code>: The URL of the S3 server.</li> <li><code>S3_ACCESS_KEY</code>: The access key of the S3 server.</li> <li><code>S3_SECRET_KEY</code>: The secret key of the S3 server.</li> <li><code>AWS_REGION</code>: The AWS region of the S3 server.</li> <li><code>S3_BUCKET</code>: The name of the S3 bucket.</li> </ul> <p>Then, it defines the <code>S3Service</code> class as a singleton, which initializes the <code>S3Client</code> with the provided configuration. The class encapsulates the following methods to interact with the S3 bucket:</p> <ul> <li><code>exists</code>: Checks if an object exists in the S3 bucket.</li> <li><code>headObject</code>: Retrieves the metadata of an object in the S3 bucket.</li> <li><code>getObjectSize</code>: Retrieves the size of an object in the S3 bucket.</li> <li><code>getObject</code>: Retrieves an object from the S3 bucket.</li> <li><code>getObjectAsJson</code>: Retrieves an object from the S3 bucket as JSON.</li> <li><code>listObjects</code>: Lists objects in the S3 bucket that match a regex pattern.</li> <li><code>deleteObject</code>: Deletes an object from the S3 bucket.</li> <li><code>run</code>: Executes an S3 command.</li> </ul>"},{"location":"tutorials/advanced-features/recording-basic/#frontend","title":"Frontend","text":"<p>The client application extends the JavaScript client tutorial by adding recording features, introducing new buttons to facilitate actions such as starting and stopping recording a room, as well as listing, playing and deleting recordings. When these newly introduced buttons are interacted with, the client triggers requests to the REST API endpoints of the server application.</p> <p>In order to update the user interface of all participants in the room according to the recording status, the client application subscribes to the <code>RoomEvent.RecordingStatusChanged</code> event, which is triggered when the room changes from being recorded to not being recorded, and vice versa. When this event is triggered, the <code>updateRecordingInfo</code> function is called to update the recording information of the room displayed on the screen. This function is also called when a participant joins the room, using the current value of the <code>room.recording</code> property at that moment. This is done in the <code>joinRoom</code> function of the <code>app.js</code> file:</p> <p>Limitations of the <code>RoomEvent.RecordingStatusChanged</code> event</p> <p>By using the <code>RoomEvent.RecordingStatusChanged</code> event, we can only detect when the recording has started or stopped, but not other states like <code>starting</code>, <code>stopping</code> or <code>failed</code>. Additionally, when the recording stops, the event is not triggered until the recorder participant leaves the room, causing a delay of 20 seconds approximately between the stop and when participants are notified.</p> <p>To overcome these limitations, you can follow the steps described in the advanced recording tutorial, where we implement a custom notification system. This system informs participants about the recording status by listening to webhook events and updating room metadata.</p> app.js<pre><code>async function joinRoom() {\n    // Disable 'Join' button\n    document.getElementById(\"join-button\").disabled = true;\n    document.getElementById(\"join-button\").innerText = \"Joining...\";\n\n    // Initialize a new Room object\n    room = new LivekitClient.Room();\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, _publication, participant) =&gt; {\n        addTrack(track, participant.identity);\n    });\n\n    // On every new Track destroyed...\n    room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track, _publication, participant) =&gt; {\n        track.detach();\n        document.getElementById(track.sid)?.remove();\n\n        if (track.kind === \"video\") {\n            removeVideoContainer(participant.identity);\n        }\n    });\n\n    // When recording status changes...\n    room.on(LivekitClient.RoomEvent.RecordingStatusChanged, async (isRecording) =&gt; {\n        await updateRecordingInfo(isRecording);\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = document.getElementById(\"room-name\").value;\n        const userName = document.getElementById(\"participant-name\").value;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName, userName);\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token);\n\n        // Hide the 'Join room' page and show the 'Room' page\n        document.getElementById(\"room-title\").innerText = roomName;\n        document.getElementById(\"join\").hidden = true;\n        document.getElementById(\"room\").hidden = false;\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone();\n        const localVideoTrack = this.room.localParticipant.videoTrackPublications.values().next().value.track;\n        addTrack(localVideoTrack, userName, true);\n\n        // Update recording info\n        await updateRecordingInfo(room.isRecording);\n    } catch (error) {\n        console.log(\"There was an error connecting to the room:\", error.message);\n        await leaveRoom();\n    }\n}\n</code></pre> <p>The <code>updateRecordingInfo</code> function updates the recording information of the room by changing the recording button's text and color according to the recording status. It also shows or hides the alert message that informs the user that the room is being recorded. Finally, it updates the recording list by calling the <code>listRecordings</code> function.</p> <p>This function retrieves all recordings available for the room from the backend and displays their relevant information by invoking the <code>showRecordingList</code> function:</p> app.js<pre><code>function showRecordingList(recordings) {\n    const recordingsList = document.getElementById(\"recording-list\");\n\n    if (recordings.length === 0) {\n        recordingsList.innerHTML = \"&lt;span&gt;There are no recordings available&lt;/span&gt;\";\n    } else {\n        recordingsList.innerHTML = \"\";\n    }\n\n    recordings.forEach((recording) =&gt; {\n        const recordingName = recording.name;\n        const recordingSize = formatBytes(recording.size ?? 0);\n        const recordingDate = new Date(recording.startedAt).toLocaleString();\n\n        const recordingContainer = document.createElement(\"div\");\n        recordingContainer.className = \"recording-container\";\n        recordingContainer.id = recordingName;\n\n        recordingContainer.innerHTML = `\n            &lt;i class=\"fa-solid fa-file-video\"&gt;&lt;/i&gt;\n            &lt;div class=\"recording-info\"&gt;\n                &lt;p class=\"recording-name\"&gt;${recordingName}&lt;/p&gt;\n                &lt;p class=\"recording-size\"&gt;${recordingSize}&lt;/p&gt;\n                &lt;p class=\"recording-date\"&gt;${recordingDate}&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;div class=\"recording-actions\"&gt;\n                &lt;button title=\"Play\" class=\"icon-button\" onclick=\"displayRecording('${recordingName}')\"&gt;\n                    &lt;i class=\"fa-solid fa-play\"&gt;&lt;/i&gt;\n                &lt;/button&gt;\n                &lt;button title=\"Delete\" class=\"icon-button delete-button\" onclick=\"deleteRecording('${recordingName}')\"&gt;\n                    &lt;i class=\"fa-solid fa-trash\"&gt;&lt;/i&gt;\n                &lt;/button&gt;\n            &lt;/div&gt;\n        `;\n\n        recordingsList.append(recordingContainer);\n    });\n}\n</code></pre> <p>The <code>showRecordingList</code> function creates a new <code>div</code> element for each recording available in the room and appends it to the <code>recording-list</code> container. Each <code>div</code> element contains the recording name, size, and start date, as well as buttons to play and delete the recording.</p> <p>Recording deletion</p> <p>When a recording is deleted, it is removed from the recording list, but only for the user who initiated the deletion. Other users will continue to see the recording in their list until it is refreshed.</p> <p>In the advanced recording tutorial, we show how to implement a custom notification system that alerts all participants of a recording's deletion by sending data messages.</p> <p>When the user clicks the play button, the <code>displayRecording</code> function is called to play the recording. This function opens a dialog window with an embedded video element and sets the source of the video to the get recording endpoint of the server application:</p> app.js<pre><code>function displayRecording(recordingName) {\n    const recordingVideoDialog = document.getElementById(\"recording-video-dialog\");\n    recordingVideoDialog.showModal();\n    const recordingVideo = document.getElementById(\"recording-video\");\n    recordingVideo.src = `/recordings/${recordingName}`;\n}\n</code></pre> index.html<pre><code>&lt;dialog id=\"recording-video-dialog\"&gt;\n    &lt;video id=\"recording-video\" autoplay controls&gt;&lt;/video&gt;\n    &lt;button class=\"btn btn-secondary\" id=\"close-recording-video-dialog\" onclick=\"closeRecording()\"&gt;Close&lt;/button&gt;\n&lt;/dialog&gt;\n</code></pre>"},{"location":"tutorials/advanced-features/recording-basic/#general-recording-page","title":"General recording page","text":"<p>The <code>recordings.html</code> file defines the HTML for the general recording page. This page lists all available recordings from all rooms and allows the user to filter them by room name. It also provides buttons to play and delete each recording.</p> <p></p> <p></p>"},{"location":"tutorials/application-client/","title":"Application Client Tutorials","text":"<p>Every application client below shares the same core functionality:</p> <ul> <li>Users request a LiveKit token to any application server to connect to a room.</li> <li>Users may publish their camera, microphone and screen-share.</li> <li>Users automatically subscribe to all media published by other users.</li> <li>Users may leave the room at any time.</li> </ul> <p>Every application client below is interchangeable with the others, because:</p> <ul> <li>All of them are compatible with each other, meaning that participants are able to join the same LiveKit room from any of the client applications.</li> <li>All of them are compatible with any application server, meaning that they can request a LiveKit token from any of the server applications.</li> </ul> <p> JavaScript</p> <p> React</p> <p> Angular</p> <p> Vue</p> <p> Electron</p> <p> Ionic</p> <p> Android</p> <p> iOS</p>"},{"location":"tutorials/application-client/android/","title":"Android Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built for Android, using Kotlin, that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit Android Kotlin SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/android/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/android/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/android/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/android/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/android/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p></p> <p></p>"},{"location":"tutorials/application-client/android/#understanding-the-code","title":"Understanding the code","text":"<p>This Android project has been generated with Android Studio. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>app/src/main/java</code> directory:</p> <ul> <li><code>MainActivity.kt</code>: This file defines the main activity of the application, which allows the user to join a video call room by providing a room name and a user name.</li> <li><code>RoomLayoutActivity.kt</code>: Activity responsible for managing the video call room, including publishing and subscribing to video and audio tracks.</li> <li><code>PaticipantAdapter.kt</code> and <code>ParticipantViewHolder.kt</code>: These files define the Adapter and ViewHolder for the RecyclerView that displays the participants video tracks in the video call room.</li> <li><code>Urls.kt</code>: Object that contains the URLs of the application server and the LiveKit server.</li> <li><code>ConfigureUrlsActivity.kt</code>: Activity that allows the user to configure the URLs of the application server and the LiveKit server.</li> </ul> <p>The activity layout files are located in the <code>app/src/main/res/layout</code> directory.</p> <p>To use LiveKit in an Android application, you need to add the LiveKit Android Kotlin SDK as a dependency in the <code>build.gradle.kts</code> file. This dependecy provides the necessary classes and methods to interact with the LiveKit server:</p> build.gradle.kts<pre><code>dependencies {\n    implementation 'io.livekit:livekit-android:2.5.0'\n}\n</code></pre> <p>You will also need JitPack as a repository in the <code>settings.gradle.kts</code> file:</p> settings.gradle.kts<pre><code>dependencyResolutionManagement {\n    //...\n    repositories {\n        google()\n        mavenCentral()\n        maven(\"https://jitpack.io\")\n    }\n}\n</code></pre>"},{"location":"tutorials/application-client/android/#android-specific-requirements","title":"Android specific requirements","text":"<p>In order to be able to test the application on an Android device, the application must ask for the necessary permissions to access the device's camera and microphone.</p> <p>First, you need to add the following permissions to the <code>AndroidManifest.xml</code> file located in the <code>app/src/main</code> directory:</p> AndroidManifest.xml<pre><code>&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n&lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /&gt;\n</code></pre> <p>Then, the app need to request these permissions when the user joins the video call room. This is done in the <code>RoomLayoutActivity.kt</code> file by calling the <code>requestNeededPermissions</code> method in the <code>onCreate</code> method:</p> RoomLayoutActivity.kt<pre><code>private fun requestNeededPermissions(onHasPermissions: () -&gt; Unit) {\n    val requestPermissionLauncher =\n        registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { grants -&gt;\n            var hasDenied = false\n\n            // Check if any permissions weren't granted\n            for (grant in grants.entries) {\n                if (!grant.value) {\n                    Toast.makeText(this, \"Missing permission: ${grant.key}\", Toast.LENGTH_SHORT)\n                        .show()\n\n                    hasDenied = true\n                }\n            }\n\n            if (!hasDenied) {\n                onHasPermissions()\n            }\n        }\n\n    // Assemble the needed permissions to request\n    val neededPermissions =\n        listOf(Manifest.permission.RECORD_AUDIO, Manifest.permission.CAMERA).filter {\n            ContextCompat.checkSelfPermission(\n                this, it\n            ) == PackageManager.PERMISSION_DENIED\n        }.toTypedArray()\n\n    if (neededPermissions.isNotEmpty()) {\n        requestPermissionLauncher.launch(neededPermissions)\n    } else {\n        onHasPermissions()\n    }\n}\n</code></pre>"},{"location":"tutorials/application-client/android/#configuring-urls","title":"Configuring URLs","text":"<p>The <code>Urls.kt</code> file defines an object that contains the following URLs required for the application:</p> <ul> <li><code>applicationServerUrl</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>livekitUrl</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> </ul> <p>You should configure these URLs according to your deployment settings. In case you are running OpenVidu locally, you can set the <code>applicationServerUrl</code> to <code>https://xxx-yyy-zzz-www.openvidu-local.dev:6443</code> and the <code>livekitUrl</code> to <code>wss://xxx-yyy-zzz-www.openvidu-local.dev:7443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is the LAN private IP address of the machine running OpenVidu, with dashes (-) instead of dots (.).</p> <p>If these URLs are left empty, the user will be prompted to enter the URLs when the application starts. This configuration is managed in the <code>ConfigureUrlsActivity.kt</code> file:</p> <p></p> <p>When the user clicks the <code>Save</code> button, the <code>onSaveUrls()</code> method is called, which saves the URLs in the <code>Urls</code> object and finishes the activity, returning to the MainActivity:</p> ConfigureUrlsActivity.kt<pre><code>private fun onSaveUrls() {\n    val serverUrl = binding.serverUrl.text.toString()\n    val livekitUrl = binding.livekitUrl.text.toString()\n\n    if (serverUrl.isNotEmpty() &amp;&amp; livekitUrl.isNotEmpty()) {\n        Urls.livekitUrl = binding.livekitUrl.text.toString()\n        Urls.applicationServerUrl = binding.serverUrl.text.toString()\n        finish()\n    } else {\n        Toast.makeText(this, \"Please fill in all fields\", Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre>"},{"location":"tutorials/application-client/android/#joining-a-room","title":"Joining a room","text":"<p>Before joining a room, the user must provide a room name and a user name. After the user specifies them, when they click the <code>Join</code> button, the <code>navigateToRoomLayoutActivity()</code> method of the <code>MainActivity.kt</code> file is called, which simply set the values of the participant name and room name in the intent and starts the <code>RoomLayoutActivity</code>:</p> MainActivity.kt<pre><code>private fun navigateToRoomLayoutActivity() {\n    binding.joinButton.isEnabled = false\n\n    val participantName = binding.participantName.text.toString()\n    val roomName = binding.roomName.text.toString()\n\n    if (participantName.isNotEmpty() &amp;&amp; roomName.isNotEmpty()) {\n        val intent = Intent(this, RoomLayoutActivity::class.java)\n        intent.putExtra(\"participantName\", participantName)\n        intent.putExtra(\"roomName\", roomName)\n        startActivity(intent)\n    } else {\n        Toast.makeText(this, \"Please fill in all fields\", Toast.LENGTH_SHORT).show()\n    }\n\n    binding.joinButton.isEnabled = true\n}\n</code></pre> <p>Now let's see the code of the <code>RoomLayoutActivity.kt</code> file:</p> RoomLayoutActivity.kt<pre><code>data class TrackInfo( // (1)!\n    val track: VideoTrack,\n    val participantIdentity: String,\n    val isLocal: Boolean = false\n)\n\nclass RoomLayoutActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityRoomLayoutBinding // (2)!\n    private lateinit var participantAdapter: ParticipantAdapter // (3)!\n\n    private lateinit var room: Room // (4)!\n    private val participantTracks: MutableList&lt;TrackInfo&gt; = mutableListOf() // (5)!\n\n    private val client = HttpClient(CIO) { // (6)!\n        expectSuccess = true\n        install(ContentNegotiation) {\n            json()\n        }\n    }\n</code></pre> <ol> <li><code>TrackInfo</code> data class, which groups a video track with the participant's identity.</li> <li>The binding object for the activity layout.</li> <li>The adapter for the RecyclerView that displays the participants' video tracks.</li> <li>The room object, which represents the video call room.</li> <li>A list of <code>TrackInfo</code> objects, which represent the video tracks of the participants in the room.</li> <li>The HTTP client used to make requests to the application server.</li> </ol> <p>The <code>RoomLayoutActivity.kt</code> file defines the following variables:</p> <ul> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>participantTracks</code>: A list of <code>TrackInfo</code> objects, which represent the video tracks of the participants in the room.</li> </ul> <p>When the activity is created, the <code>onCreate</code> method is called. This method initializes the activity layout, create a <code>Room</code> object, initializes the <code>RecyclerView</code> and request needed permissions:</p> RoomLayoutActivity.kt<pre><code>override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    binding = ActivityRoomLayoutBinding.inflate(layoutInflater)\n    setContentView(binding.root)\n\n    binding.loader.visibility = View.VISIBLE\n    binding.leaveButton.setOnClickListener {\n        leaveRoom()\n    }\n\n    // Create Room object\n    room = LiveKit.create(applicationContext)\n\n    initRecyclerView()\n\n    // Check for audio and camera permissions before connecting to the room\n    requestNeededPermissions { connectToRoom() }\n}\n</code></pre> <p>After the application check if the user has granted permissions, the <code>connectToRoom()</code> method is called:</p> RoomLayoutActivity.kt<pre><code>private fun connectToRoom() {\n    // Get the room name and participant name from the intent\n    val participantName = intent.getStringExtra(\"participantName\") ?: \"Participant1\" // (1)!\n    val roomName = intent.getStringExtra(\"roomName\") ?: \"Test Room\"\n\n    binding.roomName.text = roomName // (2)!\n\n    lifecycleScope.launch {\n        // Specify the actions when events take place in the room\n        launch {\n            room.events.collect { event -&gt;\n                when (event) {\n                    // On every new Track received...\n                    is RoomEvent.TrackSubscribed -&gt; onTrackSubscribed(event) // (3)!\n                    // On every new Track destroyed...\n                    is RoomEvent.TrackUnsubscribed -&gt; onTrackUnsubscribed(event) // (4)!\n                    else -&gt; {}\n                }\n            }\n        }\n\n        try {\n            // Get token from your application server with the room name and participant name\n            val token = getToken(roomName, participantName) // (5)!\n\n            // Connect to the room with the LiveKit URL and the token\n            room.connect(Urls.livekitUrl, token) // (6)!\n\n            // Publish your camera and microphone\n            val localParticipant = room.localParticipant\n            localParticipant.setMicrophoneEnabled(true) // (7)!\n            localParticipant.setCameraEnabled(true)\n\n            // Add local video track to the participantTracks list\n            launch {\n                localParticipant::videoTrackPublications.flow\n                    .collect { publications -&gt;\n                        val videoTrack = publications.firstOrNull()?.second as? VideoTrack\n\n                        if (videoTrack != null) {\n                            participantTracks.add( // (8)!\n                                0,\n                                TrackInfo(videoTrack, participantName, true)\n                            )\n                            participantAdapter.notifyItemInserted(0)\n                        }\n                    }\n            }\n\n            binding.loader.visibility = View.GONE\n        } catch (e: Exception) {\n            println(\"There was an error connecting to the room: ${e.message}\")\n            Toast.makeText(this@RoomLayoutActivity, \"Failed to join room\", Toast.LENGTH_SHORT)\n                .show()\n            leaveRoom()\n        }\n    }\n}\n</code></pre> <ol> <li>Get the room name and participant name from the intent.</li> <li>Set the room title in the layout.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> <li>Add local video track to the <code>participantTracks</code> list</li> </ol> <p>The <code>connectToRoom()</code> method performs the following actions:</p> <ol> <li>It retrieves the room name and participant name from the intent.</li> <li>Set the room title in the layout.</li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>participantTracks</code> list if it is a video track and notify the Adapter that a new item has been inserted.</li> </ul> RoomLayoutActivity.kt<pre><code>private fun onTrackSubscribed(event: RoomEvent.TrackSubscribed) {\n    val track = event.track\n\n    // If the track is a video track, add it to the participantTracks list\n    if (track is VideoTrack) {\n        participantTracks.add(TrackInfo(track, event.participant.identity!!.value))\n        participantAdapter.notifyItemInserted(participantTracks.size - 1)\n    }\n}\n</code></pre> <ul> <li><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the video track from the <code>participantTracks</code> list and notify the Adapter that an item has been removed.</li> </ul> RoomLayoutActivity.kt<pre><code>private fun onTrackUnsubscribed(event: RoomEvent.TrackUnsubscribed) {\n    val track = event.track\n\n    // If the track is a video track, remove it from the participantTracks list\n    if (track is VideoTrack) {\n        val index = participantTracks.indexOfFirst { it.track.sid == track.sid }\n\n        if (index != -1) {\n            participantTracks.removeAt(index)\n            participantAdapter.notifyItemRemoved(index)\n        }\n    }\n}\n</code></pre> <p>These event handlers are essential for managing the behavior of tracks within the video call.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> method:</p> RoomLayoutActivity.kt<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nprivate suspend fun getToken(roomName: String, participantName: String): String {\n    val response = client.post(Urls.applicationServerUrl + \"token\") {\n        contentType(ContentType.Application.Json)\n        setBody(TokenRequest(participantName, roomName))\n    }\n    return response.body&lt;TokenResponse&gt;().token\n}\n</code></pre> <p>This method sends a POST request using Ktor Client to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>setMicrophoneEnabled()</code> and <code>setCameraEnabled()</code> methods from <code>room.localParticipant</code>.</li> <li>It adds the local video track to the <code>participantTracks</code> list.</li> </ol>"},{"location":"tutorials/application-client/android/#displaying-video-tracks","title":"Displaying Video Tracks","text":"<p>In order to display the video tracks of the participants in the room, the <code>RoomLayoutActivity</code> uses a <code>RecyclerView</code> with a custom <code>Adapter</code> and <code>ViewHolder</code>. This allows the application to load and display the video tracks dynamically as they are received.</p> <p>Whenever a new video track is added to the <code>participantTracks</code> list, the <code>ParticipantAdapter</code> is notified that a new item has been inserted. The <code>ParticipantAdapter</code> then updates the <code>RecyclerView</code> to display the new video track by calling the <code>render</code> method of the <code>ParticipantViewHolder</code>:</p> ParticipantViewHolder.kt<pre><code>fun render(trackInfo: TrackInfo, room: Room) {\n    val participantIdentity = if (trackInfo.isLocal) {\n        trackInfo.participantIdentity + \" (You)\"\n    } else {\n        trackInfo.participantIdentity\n    }\n\n    binding.identity.text = participantIdentity // (1)!\n\n    // Only initialize the renderer once\n    if (!used) {\n        room.initVideoRenderer(binding.renderer) // (2)!\n        used = true\n    }\n\n    trackInfo.track.addRenderer(binding.renderer) // (3)!\n}\n</code></pre> <ol> <li>Set the participant identity in the layout.</li> <li>Initialize the video renderer for the participant.</li> <li>Add the video track to the renderer.</li> </ol> <p>The <code>render</code> method performs the following actions:</p> <ul> <li>It sets the participant identity in the layout.</li> <li>It initializes the video renderer for the participant. This is done only once for each participant.</li> <li>It adds the video track to the renderer.</li> </ul>"},{"location":"tutorials/application-client/android/#leaving-the-room","title":"Leaving the room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> method:</p> RoomLayoutActivity.kt<pre><code>private fun leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    room.disconnect() // (1)!\n\n    client.close() // (2)!\n\n    // Go back to the previous activity.\n    finish() // (3)!\n}\n\noverride fun onDestroy() { // (4)!\n    super.onDestroy()\n    leaveRoom()\n}\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Close the HTTP client.</li> <li>Finish the activity and go back to the previous activity.</li> <li>Call the <code>leaveRoom()</code> method when the activity is destroyed.</li> </ol> <p>The <code>leaveRoom()</code> method performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It closes the HTTP client.</li> <li>It finishes the activity and goes back to the previous activity.</li> </ul> <p>The <code>onDestroy()</code> lifecycle method is used to ensure that the user leaves the room when the activity is destroyed.</p>"},{"location":"tutorials/application-client/angular/","title":"Angular Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Angular that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/angular/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/angular/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/angular/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/angular/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/angular/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"tutorials/application-client/angular/#understanding-the-code","title":"Understanding the code","text":"<p>This Angular project has been created using the Angular CLI tool. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/app/</code> directory:</p> <ul> <li><code>app.component.ts</code>: This file defines the <code>AppComponent</code>, which serves as the main component of the application. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</li> <li><code>app.component.html</code>: This HTML file is associated with the <code>AppComponent</code>, and it dictates the structure and layout of the main application component.</li> <li><code>app.component.css</code>: The CSS file linked to <code>AppComponent</code>, which controls the styling and appearance of the application's main component.</li> <li><code>VideoComponent</code>: Component responsible for displaying video tracks along with participant's data. It is defined in the <code>video.component.ts</code> file within the <code>video</code> directory, along with its associated HTML and CSS files.</li> <li><code>AudioComponent</code>: Component responsible for displaying audio tracks. It is defined in the <code>audio.component.ts</code> file within the <code>audio</code> directory, along with its associated HTML and CSS files.</li> </ul> <p>To use the LiveKit JS SDK in an Angular application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>app.component.ts</code> file:</p> app.component.ts<pre><code>type TrackInfo = { // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// When running OpenVidu locally, leave these variables empty\n// For other deployment type, configure them with correct URLs depending on your deployment\nvar APPLICATION_SERVER_URL = ''; // (2)!\nvar LIVEKIT_URL = ''; // (3)!\n\n@Component({ // (4)!\n    selector: 'app-root',\n    standalone: true,\n    imports: [ReactiveFormsModule, AudioComponent, VideoComponent],\n    templateUrl: './app.component.html',\n    styleUrl: './app.component.css',\n})\nexport class AppComponent implements OnDestroy {\n    roomForm = new FormGroup({ // (5)!\n        roomName: new FormControl('Test Room', Validators.required),\n        participantName: new FormControl('Participant' + Math.floor(Math.random() * 100), Validators.required),\n    });\n\n    room = signal&lt;Room | undefined&gt;(undefined); // (6)!\n    localTrack = signal&lt;LocalVideoTrack | undefined&gt;(undefined); // (7)!\n    remoteTracksMap = signal&lt;Map&lt;string, TrackInfo&gt;&gt;(new Map()); // (8)!\n\n    constructor(private httpClient: HttpClient) {\n        this.configureUrls();\n    }\n\n    configureUrls() {\n        // If APPLICATION_SERVER_URL is not configured, use default value from OpenVidu Local deployment\n        if (!APPLICATION_SERVER_URL) {\n            if (window.location.hostname === 'localhost') {\n                APPLICATION_SERVER_URL = 'http://localhost:6080/';\n            } else {\n                APPLICATION_SERVER_URL = 'https://' + window.location.hostname + ':6443/';\n            }\n        }\n\n        // If LIVEKIT_URL is not configured, use default value from OpenVidu Local deployment\n        if (!LIVEKIT_URL) {\n            if (window.location.hostname === 'localhost') {\n                LIVEKIT_URL = 'ws://localhost:7880/';\n            } else {\n                LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n            }\n        }\n    }\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>Angular component decorator that defines the <code>AppComponent</code> class and associates the HTML and CSS files with it.</li> <li>The <code>roomForm</code> object, which is a form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>Map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> </ol> <p>The <code>app.component.ts</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>roomForm</code>: A form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracksMap</code>: A map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> </ul> <p>Configure the URLs</p> <p>When running OpenVidu locally, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for other deployment type, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"tutorials/application-client/angular/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> method is called:</p> app.component.ts<pre><code>async joinRoom() {\n    // Initialize a new Room object\n    const room = new Room();\n    this.room.set(room); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    this.room.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; { // (2)!\n            this.remoteTracksMap.update((map) =&gt; {\n                map.set(publication.trackSid, {\n                    trackPublication: publication,\n                    participantIdentity: participant.identity,\n                });\n                return map;\n            });\n        }\n    );\n\n    // On every new Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; { // (3)!\n        this.remoteTracksMap.update((map) =&gt; {\n            map.delete(publication.trackSid);\n            return map;\n        });\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = this.roomForm.value.roomName!; // (4)!\n        const participantName = this.roomForm.value.participantName!;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await this.getToken(roomName, participantName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (7)!\n        this.localTrack.set(room.localParticipant.videoTrackPublications.values().next().value.videoTrack);\n    } catch (error: any) {\n        console.log(\n            'There was an error connecting to the room:',\n            error?.error?.errorMessage || error?.message || error\n        );\n        await this.leaveRoom();\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> method performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracksMap</code>, which links track SIDs with <code>TrackInfo</code> objects containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracksMap</code>.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> method:</p> app.component.ts<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync getToken(roomName: string, participantName: string): Promise&lt;string&gt; {\n    const response = await lastValueFrom(\n        this.httpClient.post&lt;{ token: string }&gt;(APPLICATION_SERVER_URL + 'token', { roomName, participantName })\n    );\n    return response.token;\n}\n</code></pre> <p>This function sends a POST request using HttpClient to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> </ol>"},{"location":"tutorials/application-client/angular/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the <code>app.component.html</code> file integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> app.component.html<pre><code>&lt;div id=\"layout-container\"&gt;\n    @if (localTrack()) {\n    &lt;video-component\n        [track]=\"localTrack()!\"\n        [participantIdentity]=\"roomForm.value.participantName!\"\n        [local]=\"true\"\n    &gt;&lt;/video-component&gt;\n    }\n    @for (remoteTrack of remoteTracksMap().values(); track remoteTrack.trackPublication.trackSid) {\n        @if (remoteTrack.trackPublication.kind === 'video') {\n        &lt;video-component\n            [track]=\"remoteTrack.trackPublication.videoTrack!\"\n            [participantIdentity]=\"remoteTrack.participantIdentity\"\n        &gt;&lt;/video-component&gt;\n        } @else {\n        &lt;audio-component [track]=\"remoteTrack.trackPublication.audioTrack!\" hidden&gt;&lt;/audio-component&gt;\n        }\n    }\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>We use the Angular <code>@if</code> block to conditionally display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we use the Angular <code>@for</code> block to iterate over the <code>remoteTracksMap</code>. For each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track. The <code>hidden</code> attribute is added to the <code>AudioComponent</code> to hide the audio tracks from the layout.</p> </li> </ul> <p>Let's see now the code of the <code>video.component.ts</code> file:</p> video.component.ts<pre><code>// (1)!\n@Component({\n    selector: 'video-component',\n    standalone: true,\n    imports: [],\n    templateUrl: './video.component.html',\n    styleUrl: './video.component.css',\n})\nexport class VideoComponent implements AfterViewInit, OnDestroy {\n    videoElement = viewChild&lt;ElementRef&lt;HTMLVideoElement&gt;&gt;('videoElement'); // (2)!\n\n    track = input.required&lt;LocalVideoTrack | RemoteVideoTrack&gt;(); // (3)!\n    participantIdentity = input.required&lt;string&gt;(); // (4)!\n    local = input(false); // (5)!\n\n    ngAfterViewInit() {\n        if (this.videoElement()) {\n            this.track().attach(this.videoElement()!.nativeElement); // (6)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (7)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>VideoComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the video element in the HTML template.</li> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>Attach the video track to the video element when the track is set.</li> <li>Detach the video track when the component is destroyed.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> as inputs of the component:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the view is initialized.</li> <li>It detaches the video track when the component is destroyed.</li> </ul> <p>Finally, let's see the code of the <code>audio.component.ts</code> file:</p> audio.component.ts<pre><code>// (1)!\n@Component({\n    selector: 'audio-component',\n    standalone: true,\n    imports: [],\n    templateUrl: './audio.component.html',\n    styleUrl: './audio.component.css',\n})\nexport class AudioComponent implements AfterViewInit, OnDestroy {\n    audioElement = viewChild&lt;ElementRef&lt;HTMLAudioElement&gt;&gt;('audioElement'); // (2)!\n\n    track = input.required&lt;LocalAudioTrack | RemoteAudioTrack&gt;(); // (3)!\n\n    ngAfterViewInit() {\n        if (this.audioElement()) {\n            this.track().attach(this.audioElement()!.nativeElement); // (4)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (5)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>AudioComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the audio element in the HTML template.</li> <li>The audio track object, which can be a <code>RemoteAudioTrack</code> or a <code>LocalAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>Attach the audio track to the audio element when view is initialized.</li> <li>Detach the audio track when the component is destroyed.</li> </ol> <p>The <code>AudioComponent</code> class is similar to the <code>VideoComponent</code> class, but it is used to display audio tracks. It attaches the audio track to the audio element when view is initialized and detaches the audio track when the component is destroyed.</p>"},{"location":"tutorials/application-client/angular/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> method:</p> app.component.ts<pre><code>async leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await this.room()?.disconnect(); // (1)!\n\n    // Reset all variables\n    this.room.set(undefined); // (2)!\n    this.localTrack.set(undefined);\n    this.remoteTracksMap.set(new Map());\n}\n\n@HostListener('window:beforeunload') // (3)!\nasync ngOnDestroy() {\n    // On window closed or component destroyed, leave the room\n    await this.leaveRoom();\n}\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables.</li> <li>Call the <code>leaveRoom()</code> method when the user closes the browser window or navigates to another page.</li> </ol> <p>The <code>leaveRoom()</code> method performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It resets all variables.</li> </ul> <p>The <code>window.onbeforeunload</code> event and the <code>ngOnDestroy()</code> lifecycle hook are used to ensure that the user leaves the room when the browser window is closed or the component is destroyed.</p>"},{"location":"tutorials/application-client/electron/","title":"Electron Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Electron that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/electron/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/electron/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/electron/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/electron/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/electron/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p></p> <p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"tutorials/application-client/electron/#understanding-the-code","title":"Understanding the code","text":"<p>This Electron project has been created using electron-forge. As an Electron application, the code is divided into two main parts, the main process and the renderer process. The most important files are located within the <code>src/</code> directory:</p> <ul> <li><code>index.js</code>: This file is the entry point (main process) for the Electron application. It creates the main window and loads the <code>index.html</code> file.</li> <li><code>app.js</code>: This file constitutes the renderer process code, responsible for the application UI and logic. It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</li> <li><code>index.html</code>: This HTML file is responsible for creating the user interface. It contains the form to connect to a video call and the video call layout.</li> <li><code>styles.css</code>: This file contains CSS classes that are used to style the <code>index.html</code> page.</li> </ul> <p>To use the LiveKit JS SDK in an Electron application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>app.js</code> file:</p> app.js<pre><code>const { Room, RoomEvent } = require(\"livekit-client\"); // (1)!\n\n// Configure these constants with correct URLs depending on your deployment\nconst APPLICATION_SERVER_URL = \"http://localhost:6080/\"; // (2)!\nconst LIVEKIT_URL = \"ws://localhost:7880/\"; // (3)!\n\nvar room; // (4)!\n</code></pre> <ol> <li>Import the <code>Room</code> and <code>RoomEvent</code> classes from the <code>livekit-client</code> package.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The room object, which represents the video call room.</li> </ol> <p>The <code>app.js</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> </ul> <p>Configure the URLs</p> <p>You should configure <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> constants with the correct URLs depending on your deployment.</p>"},{"location":"tutorials/application-client/electron/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> app.js<pre><code>async function joinRoom() {\n    // Disable 'Join' button\n    document.getElementById(\"join-button\").disabled = true;\n    document.getElementById(\"join-button\").innerText = \"Joining...\";\n\n    // Initialize a new Room object\n    room = new Room(); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.on(RoomEvent.TrackSubscribed, (track, _publication, participant) =&gt; {\n        // (2)!\n        addTrack(track, participant.identity);\n    });\n\n    // On every new Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (track, _publication, participant) =&gt; {\n        // (3)!\n        track.detach();\n        document.getElementById(track.sid)?.remove();\n\n        if (track.kind === \"video\") {\n            removeVideoContainer(participant.identity);\n        }\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = document.getElementById(\"room-name\").value; // (4)!\n        const userName = document.getElementById(\"participant-name\").value;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName, userName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Hide the 'Join room' page and show the 'Room' page\n        document.getElementById(\"room-title\").innerText = roomName; // (7)!\n        document.getElementById(\"join\").hidden = true;\n        document.getElementById(\"room\").hidden = false;\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (8)!\n        const localVideoTrack = this.room.localParticipant.videoTrackPublications.values().next().value.track;\n        addTrack(localVideoTrack, userName, true);\n    } catch (error) {\n        console.log(\"There was an error connecting to the room:\", error.message);\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Hide the \"Join room\" page and show the \"Room\" page.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li>It creates a new <code>Room</code> object. This object represents the video call room.</li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It handles the attachment of the track to the HTML page, assigning an ID, and appending it to the <code>layout-container</code> element. If the track is of kind <code>video</code>, a <code>video-container</code> is created and participant data is appended as well.</li> </ul> app.js<pre><code>function addTrack(track, participantIdentity, local = false) {\n    const element = track.attach(); // (1)!\n    element.id = track.sid;\n\n    /* If the track is a video track, we create a container and append the video element to it\n    with the participant's identity */\n    if (track.kind === \"video\") {\n        const videoContainer = createVideoContainer(participantIdentity, local);\n        videoContainer.append(element);\n        appendParticipantData(videoContainer, participantIdentity + (local ? \" (You)\" : \"\"));\n    } else {\n        document.getElementById(\"layout-container\").append(element);\n    }\n}\n</code></pre> <ol> <li>Attach the track to an HTML element.</li> </ol> app.js<pre><code>function createVideoContainer(participantIdentity, local = false) {\n    const videoContainer = document.createElement(\"div\");\n    videoContainer.id = `camera-${participantIdentity}`;\n    videoContainer.className = \"video-container\";\n    const layoutContainer = document.getElementById(\"layout-container\");\n\n    if (local) {\n        layoutContainer.prepend(videoContainer);\n    } else {\n        layoutContainer.append(videoContainer);\n    }\n\n    return videoContainer;\n}\n\nfunction appendParticipantData(videoContainer, participantIdentity) {\n    const dataElement = document.createElement(\"div\");\n    dataElement.className = \"participant-data\";\n    dataElement.innerHTML = `&lt;p&gt;${participantIdentity}&lt;/p&gt;`;\n    videoContainer.prepend(dataElement);\n}\n</code></pre> <ul> <li><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of detaching the track from the HTML page and removing it from the DOM. If the track is a <code>video</code> track, <code>video-container</code> with the participant's identity is removed as well.</li> </ul> app.js<pre><code>function removeVideoContainer(participantIdentity) {\n    const videoContainer = document.getElementById(`camera-${participantIdentity}`);\n    videoContainer?.remove();\n}\n</code></pre> <p>These event handlers are essential for managing the behavior of tracks within the video call.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> app.js<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName, participantName) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName,\n            participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const token = await response.json();\n    return token.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It updates the UI to hide the \"Join room\" page and show the \"Room\" layout.</li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then added to the layout.</li> </ol>"},{"location":"tutorials/application-client/electron/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> app.js<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room.disconnect(); // (1)!\n\n    // Remove all HTML elements inside the layout container\n    removeAllLayoutElements(); // (2)!\n\n    // Back to 'Join room' page\n    document.getElementById(\"join\").hidden = false; // (3)!\n    document.getElementById(\"room\").hidden = true;\n\n    // Enable 'Join' button\n    document.getElementById(\"join-button\").disabled = false;\n    document.getElementById(\"join-button\").innerText = \"Join!\";\n}\n\n// (4)!\nwindow.onbeforeunload = () =&gt; {\n    room?.disconnect();\n};\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Remove all HTML elements inside the layout container.</li> <li>Show the \"Join room\" page and hide the \"Room\" layout.</li> <li>Call the <code>disconnect()</code> method on the <code>room</code> object when the user closes the tab or navigates to another page.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It removes all HTML elements inside the layout container by calling the <code>removeAllLayoutElements()</code> function.</li> <li>It shows the \"Join room\" page and hides the \"Room\" layout.</li> </ul> <p>The <code>window.onbeforeunload</code> event is used to ensure that the user is disconnected from the room before the page is unloaded. This event is triggered when the user closes the tab or navigates to another page.</p>"},{"location":"tutorials/application-client/ionic/","title":"Ionic Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Ionic, using Angular and Capacitor, that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/ionic/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/ionic/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/ionic/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/ionic/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/ionic/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol>"},{"location":"tutorials/application-client/ionic/#understanding-the-code","title":"Understanding the code","text":"<p>This Ionic project has been created using the Ionic CLI tool. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/app/</code> directory:</p> <ul> <li><code>app.component.ts</code>: This file defines the <code>AppComponent</code>, which serves as the main component of the application. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</li> <li><code>app.component.html</code>: This HTML file is associated with the <code>AppComponent</code>, and it dictates the structure and layout of the main application component.</li> <li><code>app.component.scss</code>: The CSS file linked to <code>AppComponent</code>, which controls the styling and appearance of the application's main component.</li> <li><code>VideoComponent</code>: Component responsible for displaying video tracks along with participant's data. It is defined in the <code>video.component.ts</code> file within the <code>video</code> directory, along with its associated HTML and CSS files.</li> <li><code>AudioComponent</code>: Component responsible for displaying audio tracks. It is defined in the <code>audio.component.ts</code> file within the <code>audio</code> directory, along with its associated HTML and CSS files.</li> </ul> <p>To use the LiveKit JS SDK in an Ionic application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>app.component.ts</code> file:</p> app.component.ts<pre><code>type TrackInfo = { // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// When running OpenVidu locally and launching app in web browser, leave these variables empty\n// For other deployment type or when launching app in a mobile device, configure them with correct URLs\n// If you leave them empty when launching app in a mobile device, the user will be prompted to enter the URLs\nvar APPLICATION_SERVER_URL = ''; // (2)!\nvar LIVEKIT_URL = ''; // (3)!\n\n@Component({ // (4)!\n    selector: 'app-root',\n    templateUrl: 'app.component.html',\n    styleUrl: 'app.component.scss',\n    standalone: true,\n    imports: [\n        IonApp,\n        VideoComponent,\n        AudioComponent,\n        ReactiveFormsModule,\n        IonHeader,\n        IonToolbar,\n        IonTitle,\n        IonButtons,\n        IonButton,\n        IonIcon,\n        IonContent,\n        IonList,\n        IonItem,\n        IonInput,\n        IonFooter,\n    ],\n})\nexport class AppComponent implements OnDestroy {\n    roomForm = new FormGroup({ // (5)!\n        roomName: new FormControl('Test Room', Validators.required),\n        participantName: new FormControl('Participant' + Math.floor(Math.random() * 100), Validators.required),\n    });\n\n    urlsForm = new FormGroup({ // (6)!\n        serverUrl: new FormControl(APPLICATION_SERVER_URL, Validators.required),\n        livekitUrl: new FormControl(LIVEKIT_URL, Validators.required),\n    });\n\n    room = signal&lt;Room | undefined&gt;(undefined); // (7)!\n    localTrack = signal&lt;LocalVideoTrack | undefined&gt;(undefined); // (8)!\n    remoteTracksMap = signal&lt;Map&lt;string, TrackInfo&gt;&gt;(new Map()); // (9)!\n\n    settingUrls = signal(false); // (10)!\n\n    constructor(private httpClient: HttpClient, private platform: Platform) {\n        this.configureUrls();\n        addIcons({\n            logoGithub,\n            book,\n            settings,\n        });\n    }\n\n    configureUrls() {\n        const mobileMode = this.platform.is('hybrid');\n\n        // If URLs are not configured and app is launched in a mobile device,\n        // prompt the user to configure them\n        if (mobileMode) {\n            if (!APPLICATION_SERVER_URL || !LIVEKIT_URL) {\n                this.settingUrls.set(true);\n            }\n        } else {\n            // If APPLICATION_SERVER_URL is not configured and app is not launched in a mobile device,\n            // use default value from OpenVidu Local deployment\n            if (!APPLICATION_SERVER_URL) {\n                if (window.location.hostname === 'localhost') {\n                    APPLICATION_SERVER_URL = 'http://localhost:6080/';\n                } else {\n                    APPLICATION_SERVER_URL = 'https://' + window.location.hostname + ':6443/';\n                }\n            }\n\n            // If LIVEKIT_URL is not configured and app is not launched in a mobile device,\n            // use default value from OpenVidu Local deployment\n            if (!LIVEKIT_URL) {\n                if (window.location.hostname === 'localhost') {\n                    LIVEKIT_URL = 'ws://localhost:7880/';\n                } else {\n                    LIVEKIT_URL = 'wss://' + window.location.hostname + ':7443/';\n                }\n            }\n        }\n    }\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>Angular component decorator that defines the <code>AppComponent</code> class and associates the HTML and CSS files with it.</li> <li>The <code>roomForm</code> object, which is a form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li>The <code>urlsForm</code> object, which is a form group that contains the <code>serverUrl</code> and <code>livekitUrl</code> fields. These fields are used to configure the application server and LiveKit URLs.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>Map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> <li>A boolean flag that indicates whether the user is configuring the application server and LiveKit URLs.</li> </ol> <p>The <code>app.component.ts</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>roomForm</code>: A form group that contains the <code>roomName</code> and <code>participantName</code> fields. These fields are used to join a video call room.</li> <li><code>urlsForm</code>: A form group that contains the <code>serverUrl</code> and <code>livekitUrl</code> fields. These fields are used to configure the application server and LiveKit URLs.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracksMap</code>: A map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> <li><code>settingUrls</code>: A boolean flag that indicates whether the user is configuring the application server and LiveKit URLs.</li> </ul>"},{"location":"tutorials/application-client/ionic/#configuring-urls","title":"Configuring URLs","text":"<p>When running OpenVidu locally and launching the app in a web browser, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for other deployment type or when launching the app in a mobile device, you should configure these variables with the correct URLs depending on your deployment.</p> <p>In case you are running OpenVidu locally and launching the app in a mobile device, you can set the <code>applicationServerUrl</code> to <code>https://xxx-yyy-zzz-www.openvidu-local.dev:6443</code> and the <code>livekitUrl</code> to <code>wss://xxx-yyy-zzz-www.openvidu-local.dev:7443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is the LAN private IP address of the machine running OpenVidu, with dashes (-) instead of dots (.).</p> <p>If you leave them empty and app is launched in a mobile device, the user will be prompted to enter the URLs when the application starts:</p> <p></p>"},{"location":"tutorials/application-client/ionic/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> method is called:</p> app.component.ts<pre><code>async joinRoom() {\n    // Initialize a new Room object\n    const room = new Room();\n    this.room.set(room); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    this.room.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; { // (2)!\n            this.remoteTracksMap.update((map) =&gt; {\n                map.set(publication.trackSid, {\n                    trackPublication: publication,\n                    participantIdentity: participant.identity,\n                });\n                return map;\n            });\n        }\n    );\n\n    // On every new Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; { // (3)!\n        this.remoteTracksMap.update((map) =&gt; {\n            map.delete(publication.trackSid);\n            return map;\n        });\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = this.roomForm.value.roomName!; // (4)!\n        const participantName = this.roomForm.value.participantName!;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await this.getToken(roomName, participantName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (7)!\n        this.localTrack.set(room.localParticipant.videoTrackPublications.values().next().value.videoTrack);\n    } catch (error: any) {\n        console.log(\n            'There was an error connecting to the room:',\n            error?.error?.errorMessage || error?.message || error\n        );\n        await this.leaveRoom();\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> method performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracksMap</code>, which links track SIDs with <code>TrackInfo</code> objects containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracksMap</code>.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> method:</p> app.component.ts<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync getToken(roomName: string, participantName: string): Promise&lt;string&gt; {\n    const response = await lastValueFrom(\n        this.httpClient.post&lt;{ token: string }&gt;(APPLICATION_SERVER_URL + 'token', { roomName, participantName })\n    );\n    return response.token;\n}\n</code></pre> <p>This function sends a POST request using HttpClient to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> </ol>"},{"location":"tutorials/application-client/ionic/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the <code>app.component.html</code> file integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> app.component.html<pre><code>&lt;div id=\"layout-container\"&gt;\n    @if (localTrack()) {\n    &lt;video-component\n        [track]=\"localTrack()!\"\n        [participantIdentity]=\"roomForm.value.participantName!\"\n        [local]=\"true\"\n    &gt;&lt;/video-component&gt;\n    }\n    @for (remoteTrack of remoteTracksMap().values(); track remoteTrack.trackPublication.trackSid) {\n        @if (remoteTrack.trackPublication.kind === 'video') {\n        &lt;video-component\n            [track]=\"remoteTrack.trackPublication.videoTrack!\"\n            [participantIdentity]=\"remoteTrack.participantIdentity\"\n        &gt;&lt;/video-component&gt;\n        } @else {\n        &lt;audio-component [track]=\"remoteTrack.trackPublication.audioTrack!\" hidden&gt;&lt;/audio-component&gt;\n        }\n    }\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>We use the Angular <code>@if</code> block to conditionally display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we use the Angular <code>@for</code> block to iterate over the <code>remoteTracksMap</code>. For each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track. The <code>hidden</code> attribute is added to the <code>AudioComponent</code> to hide the audio tracks from the layout.</p> </li> </ul> <p>Let's see now the code of the <code>video.component.ts</code> file:</p> video.component.ts<pre><code>// (1)!\n@Component({\n    selector: \"video-component\",\n    standalone: true,\n    imports: [],\n    templateUrl: \"./video.component.html\",\n    styleUrl: \"./video.component.css\"\n})\nexport class VideoComponent implements AfterViewInit, OnDestroy {\n    videoElement = viewChild&lt;ElementRef&lt;HTMLVideoElement&gt;&gt;(\"videoElement\"); // (2)!\n\n    track = input.required&lt;LocalVideoTrack | RemoteVideoTrack&gt;(); // (3)!\n    participantIdentity = input.required&lt;string&gt;(); // (4)!\n    local = input(false); // (5)!\n\n    ngAfterViewInit() {\n        if (this.videoElement()) {\n            this.track().attach(this.videoElement()!.nativeElement); // (6)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (7)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>VideoComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the video element in the HTML template.</li> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>Attach the video track to the video element when the track is set.</li> <li>Detach the video track when the component is destroyed.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> as inputs of the component:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the view is initialized.</li> <li>It detaches the video track when the component is destroyed.</li> </ul> <p>Finally, let's see the code of the <code>audio.component.ts</code> file:</p> audio.component.ts<pre><code>// (1)!\n@Component({\n    selector: \"audio-component\",\n    standalone: true,\n    imports: [],\n    templateUrl: \"./audio.component.html\",\n    styleUrl: \"./audio.component.css\"\n})\nexport class AudioComponent implements AfterViewInit, OnDestroy {\n    audioElement = viewChild&lt;ElementRef&lt;HTMLAudioElement&gt;&gt;(\"audioElement\"); // (2)!\n\n    track = input.required&lt;LocalAudioTrack | RemoteAudioTrack&gt;(); // (3)!\n\n    ngAfterViewInit() {\n        if (this.audioElement()) {\n            this.track().attach(this.audioElement()!.nativeElement); // (4)!\n        }\n    }\n\n    ngOnDestroy() {\n        this.track().detach(); // (5)!\n    }\n}\n</code></pre> <ol> <li>Angular component decorator that defines the <code>AudioComponent</code> class and associates the HTML and CSS files with it.</li> <li>The reference to the audio element in the HTML template.</li> <li>The audio track object, which can be a <code>RemoteAudioTrack</code> or a <code>LocalAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>Attach the audio track to the audio element when view is initialized.</li> <li>Detach the audio track when the component is destroyed.</li> </ol> <p>The <code>AudioComponent</code> class is similar to the <code>VideoComponent</code> class, but it is used to display audio tracks. It attaches the audio track to the audio element when view is initialized and detaches the audio track when the component is destroyed.</p>"},{"location":"tutorials/application-client/ionic/#leaving-the-room","title":"Leaving the room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> method:</p> app.component.ts<pre><code>async leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await this.room()?.disconnect(); // (1)!\n\n    // Reset all variables\n    this.room.set(undefined); // (2)!\n    this.localTrack.set(undefined);\n    this.remoteTracksMap.set(new Map());\n}\n\nasync ngOnDestroy() { // (3)!\n    // On window closed or component destroyed, leave the room\n    await this.leaveRoom();\n}\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables.</li> <li>Call the <code>leaveRoom()</code> method when the component is destroyed.</li> </ol> <p>The <code>leaveRoom()</code> method performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It resets all variables.</li> </ul> <p>The <code>ngOnDestroy()</code> lifecycle hook is used to ensure that the user leaves the room when the component is destroyed.</p>"},{"location":"tutorials/application-client/ionic/#specific-mobile-requirements","title":"Specific mobile requirements","text":"<p>In order to be able to test the application on an Android or iOS device, the application must ask for the necessary permissions to access the device's camera and microphone. These permissions are requested when the user joins the video call room.</p>  Android iOS <p>The application must include the following permissions in the <code>AndroidManifest.xml</code> file located in the <code>android/app/src/main</code> directory:</p> AndroidManifest.xml<pre><code>&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt;\n&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt;\n&lt;uses-permission android:name=\"android.permission.MODIFY_AUDIO_SETTINGS\" /&gt;\n</code></pre> <p>The application must include the following permissions in the <code>Info.plist</code> file located in the <code>ios/App/App</code> directory:</p> Info.plist<pre><code>&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;This Application uses your camera to make video calls.&lt;/string&gt;\n&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n&lt;string&gt;This Application uses your microphone to make calls.&lt;/string&gt;\n</code></pre>"},{"location":"tutorials/application-client/ios/","title":"iOS Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built for iOS, using Swift, that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit Swift SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/ios/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/ios/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/ios/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/ios/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/ios/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p></p> <p></p>"},{"location":"tutorials/application-client/ios/#understanding-the-code","title":"Understanding the Code","text":"<p>This iOS project, created with Xcode and written in Swift, includes various files and directories. For this tutorial, focus on the following key components within the <code>openvidu-ios/Shared</code> directory:</p> <ul> <li><code>OpenViduApp.swift</code>: Initializes the application and sets up the main view.</li> <li><code>Support</code>: Contains files for secure storage, token management, and other support functions.</li> <li><code>Utils</code>: Includes utility files like <code>HttpClient.swift</code> for HTTP networking.</li> <li><code>Views</code>: Houses the user interface components of the application.</li> <li><code>Contexts</code>: Manages application state and room contexts for LiveKit interaction.</li> <li><code>Assets.xcassets</code>: Stores images and color assets used in the app.</li> </ul>"},{"location":"tutorials/application-client/ios/#integrating-livekit","title":"Integrating LiveKit","text":"<p>To use LiveKit in your iOS app, you need to add the LiveKit Swift SDK as a Swift Package. You can do this using either <code>Package.swift</code> or Xcode.</p>"},{"location":"tutorials/application-client/ios/#adding-livekit-via-packageswift","title":"Adding LiveKit via <code>Package.swift</code>","text":"<ol> <li>Open your <code>Package.swift</code> file.</li> <li>Add LiveKit to the <code>dependencies</code> array.</li> <li>Include LiveKit in the <code>targets</code> array.</li> </ol> <p>Example <code>Package.swift</code>:</p> <pre><code>// swift-tools-version:5.3\nimport PackageDescription\n\nlet package = Package(\n    name: \"MyApp\",\n    platforms: [.iOS(.v14)],\n    dependencies: [\n        .package(name: \"LiveKit\", url: \"https://github.com/livekit/client-sdk-swift.git\", .upToNextMajor(from: \"2.0.12\"))\n    ],\n    targets: [\n        .target(\n            name: \"MyApp\",\n            dependencies: [\"LiveKit\"]\n        )\n    ]\n)\n</code></pre>"},{"location":"tutorials/application-client/ios/#adding-livekit-via-xcode","title":"Adding LiveKit via Xcode","text":"<ol> <li>Open your Xcode project.</li> <li>Go to Project Settings.</li> <li>Select the Swift Packages tab.</li> <li>Click the + button to add a new package.</li> <li>Enter the URL: <code>https://github.com/livekit/client-sdk-swift</code>.</li> <li>Choose the version you want, such as \"Up to Next Major Version\" with <code>2.0.12</code>.</li> </ol>"},{"location":"tutorials/application-client/ios/#ios-specific-requirements","title":"iOS Specific Requirements","text":"<p>To test the application on an iOS device, you need to ensure it has permission to access the camera and microphone. These configurations are already included in this project. However, if you're starting a new project, follow these steps:</p> <ol> <li> <p>Add Permissions to <code>Info.plist</code></p> <p>Include the following keys in your <code>Info.plist</code> file to request access to the camera and microphone:</p> <pre><code>&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;$(PRODUCT_NAME) needs camera access to capture and transmit video&lt;/string&gt;\n&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n&lt;string&gt;$(PRODUCT_NAME) needs microphone access to capture and transmit audio&lt;/string&gt;\n</code></pre> </li> <li> <p>Automatic Permission Requests</p> <p>The app will automatically request these permissions when it runs.</p> </li> <li> <p>Check Permissions</p> <p>To verify if the permissions were granted, use the <code>AVCaptureDevice.requestAccess(for: .video)</code> method:</p> <pre><code>AVCaptureDevice.requestAccess(for: .video) { granted in\n    if granted {\n        print(\"Camera access granted\")\n    } else {\n        print(\"Camera access denied\")\n    }\n}\n</code></pre> </li> </ol>"},{"location":"tutorials/application-client/ios/#configuring-urls","title":"Configuring URLs","text":"<p>The <code>ConfigureUrlsView.swift</code> file defines a SwiftUI view for configuring the URLs required for the application:</p> <ul> <li><code>applicationServerUrl</code>: The URL of the application server used to obtain tokens for joining the video call room.</li> <li><code>livekitUrl</code>: The URL of the LiveKit server used to connect to the video call room and handle video communication.</li> </ul> <p>You should configure these URLs according to your deployment settings. If you are running OpenVidu locally, you can set <code>applicationServerUrl</code> to <code>https://xxx-yyy-zzz-www.openvidu-local.dev:6443</code> and <code>livekitUrl</code> to <code>wss://xxx-yyy-zzz-www.openvidu-local.dev:7443</code>, where <code>xxx-yyy-zzz-www</code> represents the LAN private IP address of the machine running OpenVidu, with dashes (-) instead of dots (.).</p> <p>If these URLs are left empty, the user will be prompted to enter them when the application starts. This configuration is managed in the <code>ConfigureUrlsView.swift</code> file:</p> <p></p> <p>When the user clicks the <code>Save</code> button, the <code>LKButton</code> action triggers the validation and saves the URLs into the <code>AppContext</code> and <code>RoomContext</code>. The <code>ConfigureUrlsView</code> handles this logic:</p> ConfigureUrlsView.swift<pre><code>LKButton(title: \"Save\") {\n    Task.detached { @MainActor in\n        let isApplicationServerValid = isValidURL(self.applicationServerUrl)\n        let isLivekitUrlValid = isValidURL(self.livekitUrl)\n\n        if !isApplicationServerValid || !isLivekitUrlValid {\n            print(\"Invalid URLs\")\n            errorMessage = \"There was an error with the URL values\"\n            return\n        }\n        appCtx.applicationServerUrl = self.applicationServerUrl\n        roomCtx.livekitUrl = self.livekitUrl\n        errorMessage = \"\"\n    }\n}\n</code></pre> <p>In this code snippet, the <code>isValidURL</code> function checks the validity of the URLs. If both URLs are valid, they are saved into the <code>appCtx</code> and <code>roomCtx</code> contexts. If any URL is invalid, an error message is displayed.</p>"},{"location":"tutorials/application-client/ios/#joining-a-room","title":"Joining a room","text":"<p>Before joining a room, the <code>ConnectView.swift</code> defines the view for the connection screen. It includes a logo, text fields for participant name and room name, and buttons for joining the room and resetting URLs.</p> <p></p> <p>After define the participant and room name, the user can click the <code>Join</code> button to connect to the room. This action triggers the <code>connectToRoom</code> method asynchronously:</p> ConnectView.swift<pre><code>func connectToRoom() async {\n    let livekitUrl = roomCtx.livekitUrl\n    let roomName = roomCtx.name\n    let participantName = roomCtx.localParticipantName\n    let applicationServerUrl = appCtx.applicationServerUrl\n\n    guard !livekitUrl.isEmpty, !roomName.isEmpty else {\n        print(\"LiveKit URL or room name is empty\")\n        return\n    }\n\n    do {\n        let token = try await httpService.getToken(\n            applicationServerUrl: applicationServerUrl, roomName: roomName,\n            participantName: participantName)// (1)!\n\n        if token.isEmpty {\n            print(\"Received empty token\")\n            return\n        }\n\n        roomCtx.token = token\n        print(\"Connecting to room...\")\n        try await roomCtx.connect() // (2)!\n        print(\"Room connected\")\n        await enableCameraAndMicrophone() // (3)!\n\n    } catch {\n        print(\"Failed to get token: \\(error.localizedDescription)\")\n    }\n}\n\nfunc enableCameraAndMicrophone() async {\n    do {\n        try await room.localParticipant.setCamera(enabled: true) // (4)!\n        try await room.localParticipant.setMicrophone(enabled: true) // (5)!\n    } catch {\n        print(\"Error enabling camera and microphone: \\(error.localizedDescription)\")\n    }\n}\n</code></pre> <ol> <li>The <code>getToken</code> method is called to request a token from the application server.</li> <li>The <code>connect</code> method is called to connect to the room using the LiveKit URL and the token.</li> <li>The <code>enableCameraAndMicrophone</code> method is called to enable the camera and microphone for the local participant.</li> <li>The <code>setCamera</code> method is called to enable the camera for the local participant.</li> <li>The <code>setMicrophone</code> method is called to enable the microphone for the local participant.</li> </ol> <p>The <code>OpenViduApp.swift</code> handle the navigation page. When room status is <code>connected</code>, the user is redirected to the <code>RoomView</code>:</p> OpenViduApp.swift<pre><code>struct RoomSwitchView: View {\n    @EnvironmentObject var appCtx: AppContext\n    @EnvironmentObject var roomCtx: RoomContext\n    @EnvironmentObject var room: Room\n\n    var shouldShowRoomView: Bool {\n        room.connectionState == .connected || room.connectionState == .reconnecting\n    }\n\n    var shouldShowConfigureUrlsView: Bool {\n        appCtx.applicationServerUrl.isEmpty || roomCtx.livekitUrl.isEmpty\n\n    }\n\n    var body: some View {\n        ZStack {\n            Color.black\n                .ignoresSafeArea()\n\n            // Navigation logic\n            if shouldShowRoomView {\n                RoomView() // (1)!\n            } else {\n                if shouldShowConfigureUrlsView {\n                    ConfigureUrlsView() // (2)!\n                } else {\n                    ConnectView() // (3)!\n                }\n            }\n        }\n        .navigationTitle(computeTitle())\n    }\n}\n</code></pre> <ol> <li>If the room is connected, the user is redirected to the <code>RoomView</code>.</li> <li>If the URLs are not configured, the user is redirected to the <code>ConfigureUrlsView</code>.</li> <li>If the room is not connected and the URLs are configured, the user is redirected to the <code>ConnectView</code>.</li> </ol>"},{"location":"tutorials/application-client/ios/#displaying-video-tracks","title":"Displaying Video Tracks","text":"<p>To display the video tracks of participants in the room, the <code>RoomView.swift</code> uses various SwiftUI views and custom components. This approach allows the application to dynamically load and display the video tracks as they are received.</p> RoomView.swift<pre><code>struct RoomView: View {\n    @EnvironmentObject var appCtx: AppContext\n    @EnvironmentObject var roomCtx: RoomContext\n    @EnvironmentObject var room: Room\n\n    @State var isCameraPublishingBusy = false\n    @State var isMicrophonePublishingBusy = false\n\n    // ...\n\n    func content(geometry: GeometryProxy) -&gt; some View {\n        VStack {\n            // ...\n\n            // Display Participant layout\n            HorVStack(axis: geometry.isTall ? .vertical : .horizontal, spacing: 5) {\n                Group {\n                    ParticipantLayout(sortedParticipants(), spacing: 5) { participant in // (1)!\n                        ParticipantView(participant: participant, videoViewMode: .fill) // (2)!\n                    }\n                }\n                .frame(\n                    minWidth: 0,\n                    maxWidth: .infinity,\n                    minHeight: 0,\n                    maxHeight: .infinity\n                )\n            }\n            .padding(5)\n        }\n    }\n}\n</code></pre> <ol> <li>The <code>ParticipantLayout</code> component is used to display the video tracks of all participants in the room. It receives the sorted list of participants and a closure that returns a <code>ParticipantView</code> for each participant.</li> <li>The <code>ParticipantView</code> component is used to display the video track of a participant.</li> </ol> <p>The <code>ParticipantView</code> component is responsible for rendering the video track of a participant. It uses the <code>SwiftUIVideoView</code> component to display the video track and the <code>VideoView.LayoutMode</code> enum to define the layout mode.</p> <p>The LiveKit Swift SDK includes a VideoView class, based on UIKit, specifically designed for rendering video tracks. Additionally, subscribed audio tracks are automatically played by default.</p> ParticipantView.swift<pre><code>struct ParticipantView: View {\n    @ObservedObject var participant: Participant\n    @EnvironmentObject var appCtx: AppContext\n\n    var videoViewMode: VideoView.LayoutMode = .fill\n\n\n    // ...\n\n     var body: some View {\n        GeometryReader { geometry in\n            ZStack(alignment: .bottom) {\n\n                // ...\n\n                // VideoView for the Participant\n                if let publication = participant.mainVideoPublication,\n                    !publication.isMuted,\n                    let track = publication.track as? VideoTrack\n                {\n                    ZStack(alignment: .topLeading) {\n                        SwiftUIVideoView(track, // (1)!\n                                            layoutMode: videoViewMode,\n                                            isRendering: $isRendering)\n                    }\n                }\n            }\n        }\n     }\n\n}\n</code></pre> <ol> <li>The <code>SwiftUIVideoView</code> component renders the participant's video track.</li> </ol>"},{"location":"tutorials/application-client/ios/#leaving-the-room","title":"Leaving the room","text":"<p>To leave the room, the user can click the <code>Leave</code> button in the <code>RoomView</code>. This action triggers the <code>leaveRoom</code> method asynchronously:</p> RoomView.swift<pre><code>func content(geometry: GeometryProxy) -&gt; some View {\n\n    // ...\n\n    Button(action: {\n        Task {\n            await roomCtx.disconnect()\n        }\n    }, label: {\n        HStack {\n            Image(systemSymbol: .xmarkCircleFill)\n                .renderingMode(.original)\n            Text(\"Leave Room\")\n                .font(.headline)\n                .fontWeight(.semibold)\n        }\n        .padding(8)\n        .background(Color.red.opacity(0.8)) // Background color for the button\n        .foregroundColor(.white) // Text color\n        .cornerRadius(8)\n    })\n}\n</code></pre> <p>After rome is disconnected, the room status is updated to <code>disconnected</code> and the <code>OpenViduApp.swift</code> handle this update to redirect the user to the <code>ConnectView</code>.</p>"},{"location":"tutorials/application-client/javascript/","title":"JavaScript Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with plain JavaScript, HTML and CSS that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/javascript/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/javascript/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/javascript/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/javascript/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/javascript/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"tutorials/application-client/javascript/#understanding-the-code","title":"Understanding the code","text":"<p>This application is designed to be beginner-friendly and consists of only three essential files that are located in the <code>src</code> directory:</p> <ul> <li><code>app.js</code>: This is the main JavaScript file for the sample application. It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</li> <li><code>index.html</code>: This HTML file is responsible for creating the user interface. It contains the form to connect to a video call and the video call layout.</li> <li><code>styles.css</code>: This file contains CSS classes that are used to style the <code>index.html</code> page.</li> </ul> <p>To use the LiveKit JS SDK in your application, you need to include the library in your HTML file. You can do this by adding the following script tag to the <code>&lt;head&gt;</code> section of your HTML file:</p> index.html<pre><code>&lt;script src=\"https://cdn.jsdelivr.net/npm/livekit-client@2.5.9/dist/livekit-client.umd.js\"&gt;&lt;/script&gt;\n</code></pre> <p>Then, you can use the <code>LivekitClient</code> object in your JavaScript code by referencing it from the <code>window</code> object under <code>LivekitClient</code>. When accessing symbols from the class, you will need to prefix them with <code>LivekitClient.</code>. For example, <code>Room</code> becomes <code>LivekitClient.Room</code>.</p> <p>Now let's see the code of the <code>app.js</code> file:</p> app.js<pre><code>// When running OpenVidu locally, leave these variables empty\n// For other deployment type, configure them with correct URLs depending on your deployment\nvar APPLICATION_SERVER_URL = \"\"; // (1)!\nvar LIVEKIT_URL = \"\"; // (2)!\nconfigureUrls();\n\nconst LivekitClient = window.LivekitClient; // (3)!\nvar room; // (4)!\n\nfunction configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from OpenVidu Local deployment\n    if (!APPLICATION_SERVER_URL) {\n        if (window.location.hostname === \"localhost\") {\n            APPLICATION_SERVER_URL = \"http://localhost:6080/\";\n        } else {\n            APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443/\";\n        }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from OpenVidu Local deployment\n    if (!LIVEKIT_URL) {\n        if (window.location.hostname === \"localhost\") {\n            LIVEKIT_URL = \"ws://localhost:7880/\";\n        } else {\n            LIVEKIT_URL = \"wss://\" + window.location.hostname + \":7443/\";\n        }\n    }\n}\n</code></pre> <ol> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The LivekitClient object, which is the entry point to the LiveKit JS SDK.</li> <li>The room object, which represents the video call room.</li> </ol> <p>The <code>app.js</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>LivekitClient</code>: The LiveKit JS SDK object, which is the entry point to the LiveKit JS SDK.</li> <li><code>room</code>: The room object, which represents the video call room.</li> </ul> <p>Configure the URLs</p> <p>When running OpenVidu locally, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for other deployment type, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"tutorials/application-client/javascript/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> app.js<pre><code>async function joinRoom() {\n    // Disable 'Join' button\n    document.getElementById(\"join-button\").disabled = true;\n    document.getElementById(\"join-button\").innerText = \"Joining...\";\n\n    // Initialize a new Room object\n    room = new LivekitClient.Room(); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, _publication, participant) =&gt; {\n        // (2)!\n        addTrack(track, participant.identity);\n    });\n\n    // On every new Track destroyed...\n    room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track, _publication, participant) =&gt; {\n        // (3)!\n        track.detach();\n        document.getElementById(track.sid)?.remove();\n\n        if (track.kind === \"video\") {\n            removeVideoContainer(participant.identity);\n        }\n    });\n\n    try {\n        // Get the room name and participant name from the form\n        const roomName = document.getElementById(\"room-name\").value; // (4)!\n        const userName = document.getElementById(\"participant-name\").value;\n\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName, userName); // (5)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (6)!\n\n        // Hide the 'Join room' page and show the 'Room' page\n        document.getElementById(\"room-title\").innerText = roomName; // (7)!\n        document.getElementById(\"join\").hidden = true;\n        document.getElementById(\"room\").hidden = false;\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (8)!\n        const localVideoTrack = this.room.localParticipant.videoTrackPublications.values().next().value.track;\n        addTrack(localVideoTrack, userName, true);\n    } catch (error) {\n        console.log(\"There was an error connecting to the room:\", error.message);\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get the room name and participant name from the form.</li> <li>Get a token from the application server with the room name and participant name.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Hide the \"Join room\" page and show the \"Room\" page.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li>It creates a new <code>Room</code> object using <code>LivekitClient.Room()</code>. This object represents the video call room.</li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li><code>LivekitClient.RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It handles the attachment of the track to the HTML page, assigning an ID, and appending it to the <code>layout-container</code> element. If the track is of kind <code>video</code>, a <code>video-container</code> is created and participant data is appended as well.</li> </ul> app.js<pre><code>function addTrack(track, participantIdentity, local = false) {\n    const element = track.attach(); // (1)!\n    element.id = track.sid;\n\n    /* If the track is a video track, we create a container and append the video element to it\n    with the participant's identity */\n    if (track.kind === \"video\") {\n        const videoContainer = createVideoContainer(participantIdentity, local);\n        videoContainer.append(element);\n        appendParticipantData(videoContainer, participantIdentity + (local ? \" (You)\" : \"\"));\n    } else {\n        document.getElementById(\"layout-container\").append(element);\n    }\n}\n</code></pre> <ol> <li>Attach the track to an HTML element.</li> </ol> app.js<pre><code>function createVideoContainer(participantIdentity, local = false) {\n    const videoContainer = document.createElement(\"div\");\n    videoContainer.id = `camera-${participantIdentity}`;\n    videoContainer.className = \"video-container\";\n    const layoutContainer = document.getElementById(\"layout-container\");\n\n    if (local) {\n        layoutContainer.prepend(videoContainer);\n    } else {\n        layoutContainer.append(videoContainer);\n    }\n\n    return videoContainer;\n}\n\nfunction appendParticipantData(videoContainer, participantIdentity) {\n    const dataElement = document.createElement(\"div\");\n    dataElement.className = \"participant-data\";\n    dataElement.innerHTML = `&lt;p&gt;${participantIdentity}&lt;/p&gt;`;\n    videoContainer.prepend(dataElement);\n}\n</code></pre> <ul> <li><code>LivekitClient.RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of detaching the track from the HTML page and removing it from the DOM. If the track is a <code>video</code> track, <code>video-container</code> with the participant's identity is removed as well.</li> </ul> app.js<pre><code>function removeVideoContainer(participantIdentity) {\n    const videoContainer = document.getElementById(`camera-${participantIdentity}`);\n    videoContainer?.remove();\n}\n</code></pre> <p>These event handlers are essential for managing the behavior of tracks within the video call.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It retrieves the room name and participant name from the form.</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> app.js<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName, participantName) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName,\n            participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const token = await response.json();\n    return token.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It updates the UI to hide the \"Join room\" page and show the \"Room\" layout.</li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then added to the layout.</li> </ol>"},{"location":"tutorials/application-client/javascript/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> app.js<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room.disconnect(); // (1)!\n\n    // Remove all HTML elements inside the layout container\n    removeAllLayoutElements(); // (2)!\n\n    // Back to 'Join room' page\n    document.getElementById(\"join\").hidden = false; // (3)!\n    document.getElementById(\"room\").hidden = true;\n\n    // Enable 'Join' button\n    document.getElementById(\"join-button\").disabled = false;\n    document.getElementById(\"join-button\").innerText = \"Join!\";\n}\n\n// (4)!\nwindow.onbeforeunload = () =&gt; {\n    room?.disconnect();\n};\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Remove all HTML elements inside the layout container.</li> <li>Show the \"Join room\" page and hide the \"Room\" layout.</li> <li>Call the <code>disconnect()</code> method on the <code>room</code> object when the user closes the tab or navigates to another page.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>room</code> object.</li> <li>It removes all HTML elements inside the layout container by calling the <code>removeAllLayoutElements()</code> function.</li> <li>It shows the \"Join room\" page and hides the \"Room\" layout.</li> </ul> <p>The <code>window.onbeforeunload</code> event is used to ensure that the user is disconnected from the room before the page is unloaded. This event is triggered when the user closes the tab or navigates to another page.</p>"},{"location":"tutorials/application-client/react/","title":"React Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with React that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/react/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/react/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/react/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/react/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/react/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"tutorials/application-client/react/#understanding-the-code","title":"Understanding the code","text":"<p>This React project has been generated using the Vite. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/</code> directory:</p> <ul> <li><code>App.tsx</code>: This file defines the main application component. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</li> <li><code>App.css</code>: This file contains the styles for the main application component.</li> <li><code>VideoComponent.tsx</code>: This file defines the <code>VideoComponent</code>. This component is responsible for displaying video tracks along with participant's data. Its associated styles are in <code>VideoComponent.css</code>.</li> <li><code>AudioComponent.vue</code>: This file defines the <code>AudioComponent</code>. This component is responsible for displaying audio tracks.</li> </ul> <p>To use the LiveKit JS SDK in a Vue application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>App.tsx</code> file:</p> App.tsx<pre><code>type TrackInfo = { // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// When running OpenVidu locally, leave these variables empty\n// For other deployment type, configure them with correct URLs depending on your deployment\nlet APPLICATION_SERVER_URL = \"\"; // (2)!\nlet LIVEKIT_URL = \"\"; // (3)!\nconfigureUrls();\n\nfunction configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from OpenVidu Local deployment\n    if (!APPLICATION_SERVER_URL) {\n        if (window.location.hostname === \"localhost\") {\n            APPLICATION_SERVER_URL = \"http://localhost:6080/\";\n        } else {\n            APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443/\";\n        }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from OpenVidu Local deployment\n    if (!LIVEKIT_URL) {\n        if (window.location.hostname === \"localhost\") {\n            LIVEKIT_URL = \"ws://localhost:7880/\";\n        } else {\n            LIVEKIT_URL = \"wss://\" + window.location.hostname + \":7443/\";\n        }\n    }\n}\n\nfunction App() {\n    const [room, setRoom] = useState&lt;Room | undefined&gt;(undefined); // (4)!\n    const [localTrack, setLocalTrack] = useState&lt;LocalVideoTrack | undefined&gt;(undefined); // (5)!\n    const [remoteTracks, setRemoteTracks] = useState&lt;TrackInfo[]&gt;([]); // (6)!\n\n    const [participantName, setParticipantName] = useState(\"Participant\" + Math.floor(Math.random() * 100)); // (7)!\n    const [roomName, setRoomName] = useState(\"Test Room\"); // (8)!\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>The remote tracks array.</li> <li>The participant's name.</li> <li>The room name.</li> </ol> <p>The <code>App.tsx</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracks</code>: An array of <code>TrackInfo</code> objects, which group a track publication with the participant's identity.</li> <li><code>participantName</code>: The participant's name.</li> <li><code>roomName</code>: The room name.</li> </ul> <p>Configure the URLs</p> <p>When running OpenVidu locally, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for other deployment type, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"tutorials/application-client/react/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> App.tsx<pre><code>async function joinRoom() {\n    // Initialize a new Room object\n    const room = new Room(); // (1)!\n    setRoom(room);\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; {\n            // (2)!\n            setRemoteTracks((prev) =&gt; [\n                ...prev,\n                { trackPublication: publication, participantIdentity: participant.identity }\n            ]);\n        }\n    );\n\n    // On every Track destroyed...\n    room.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; {\n        // (3)!\n        setRemoteTracks((prev) =&gt; prev.filter((track) =&gt; track.trackPublication.trackSid !== publication.trackSid));\n    });\n\n    try {\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName, participantName); // (4)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.connect(LIVEKIT_URL, token); // (5)!\n\n        // Publish your camera and microphone\n        await room.localParticipant.enableCameraAndMicrophone(); // (6)!\n        setLocalTrack(room.localParticipant.videoTrackPublications.values().next().value.videoTrack);\n    } catch (error) {\n        console.log(\"There was an error connecting to the room:\", (error as Error).message);\n        await leaveRoom();\n    }\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get a token from the application server with the room name and participant name from the form.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracks</code> array as a <code>TrackInfo</code> object containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracks</code> array.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> App.tsx<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName: string, participantName: string) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName: roomName,\n            participantName: participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const data = await response.json();\n    return data.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> </ol>"},{"location":"tutorials/application-client/react/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the main component integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> App.tsx<pre><code>&lt;div id=\"layout-container\"&gt;\n    {localTrack &amp;&amp; (\n        &lt;VideoComponent track={localTrack} participantIdentity={participantName} local={true} /&gt;\n    )}\n    {remoteTracks.map((remoteTrack) =&gt;\n        remoteTrack.trackPublication.kind === \"video\" ? (\n            &lt;VideoComponent\n                key={remoteTrack.trackPublication.trackSid}\n                track={remoteTrack.trackPublication.videoTrack!}\n                participantIdentity={remoteTrack.participantIdentity}\n            /&gt;\n        ) : (\n            &lt;AudioComponent\n                key={remoteTrack.trackPublication.trackSid}\n                track={remoteTrack.trackPublication.audioTrack!}\n            /&gt;\n        )\n    )}\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>If the property <code>localTrack</code> is defined, we display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we iterate over the <code>remoteTracks</code> array and, for each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track.</p> </li> </ul> <p>Let's see now the code of the <code>VideoComponent.txs</code> file:</p> VideoComponent.tsx<pre><code>interface VideoComponentProps {\n    track: LocalVideoTrack | RemoteVideoTrack; // (1)!\n    participantIdentity: string; // (2)!\n    local?: boolean; // (3)!\n}\n\nfunction VideoComponent({ track, participantIdentity, local = false }: VideoComponentProps) {\n    const videoElement = useRef&lt;HTMLVideoElement | null&gt;(null); // (4)!\n\n    useEffect(() =&gt; {\n        if (videoElement.current) {\n            track.attach(videoElement.current); // (5)!\n        }\n\n        return () =&gt; {\n            track.detach(); // (6)!\n        };\n    }, [track]);\n\n    return (\n        &lt;div id={\"camera-\" + participantIdentity} className=\"video-container\"&gt;\n            &lt;div className=\"participant-data\"&gt;\n                &lt;p&gt;{participantIdentity + (local ? \" (You)\" : \"\")}&lt;/p&gt;\n            &lt;/div&gt;\n            &lt;video ref={videoElement} id={track.sid}&gt;&lt;/video&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre> <ol> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>The reference to the video element in the HTML template.</li> <li>Attach the video track to the video element when the component is mounted.</li> <li>Detach the video track when the component is unmounted.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> as props of the component:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the component is mounted.</li> <li>It detaches the video track when the component is unmounted.</li> </ul> <p>Finally, let's see the code of the <code>AudioComponent.tsx</code> file:</p> AudioComponent.tsx<pre><code>interface AudioComponentProps {\n    track: LocalAudioTrack | RemoteAudioTrack; // (1)!\n}\n\nfunction AudioComponent({ track }: AudioComponentProps) {\n    const audioElement = useRef&lt;HTMLAudioElement | null&gt;(null); // (2)!\n\n    useEffect(() =&gt; {\n        if (audioElement.current) {\n            track.attach(audioElement.current); // (3)!\n        }\n\n        return () =&gt; {\n            track.detach(); // (4)!\n        };\n    }, [track]);\n\n    return &lt;audio ref={audioElement} id={track.sid} /&gt;;\n}\n</code></pre> <ol> <li>The audio track object, which can be a <code>LocalAudioTrack</code> or a <code>RemoteAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>The reference to the audio element in the HTML template.</li> <li>Attach the audio track to the audio element when the component is mounted.</li> <li>Detach the audio track when the component is unmounted.</li> </ol> <p>The <code>AudioComponent</code> is similar to the <code>VideoComponent</code> but is used to display audio tracks. It defines the <code>track</code> property as a prop for the component and creates a reference to the audio element in the HTML template. The audio track is attached to the audio element when the component is mounted and detached when the component is unmounted.</p>"},{"location":"tutorials/application-client/react/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> App.tsx<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room?.disconnect(); // (1)!\n\n    // Reset the state\n    setRoom(undefined); // (2)!\n    setLocalTrack(undefined);\n    setRemoteTracks([]);\n}\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables to their initial state.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>Room</code> object.</li> <li>It resets all variables to their initial state.</li> </ul>"},{"location":"tutorials/application-client/vue/","title":"Vue Tutorial","text":"<p>Source code </p> <p>This tutorial is a simple video-call application built with Vue that allows:</p> <ul> <li>Joining a video call room by requesting a token from any application server.</li> <li>Publishing your camera and microphone.</li> <li>Subscribing to all other participants' video and audio tracks automatically.</li> <li>Leaving the video call room at any time.</li> </ul> <p>It uses the LiveKit JS SDK to connect to the LiveKit server and interact with the video call room.</p>"},{"location":"tutorials/application-client/vue/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-client/vue/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-client/vue/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-client/vue/#3-run-a-server-application","title":"3. Run a server application","text":"Node.js Go Ruby Java Python Rust PHP .NET <p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol> <p>For more information, check the Node.js tutorial.</p> <p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol> <p>For more information, check the Go tutorial.</p> <p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol> <p>For more information, check the Ruby tutorial.</p> <p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol> <p>For more information, check the Java tutorial.</p> <p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol> <p>For more information, check the Python tutorial.</p> <p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol> <p>For more information, check the Rust tutorial.</p> <p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p> <p>For more information, check the PHP tutorial.</p> <p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p> <p>For more information, check the .NET tutorial.</p>"},{"location":"tutorials/application-client/vue/#4-run-the-client-application","title":"4. Run the client application","text":"<p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p></p> <p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p>"},{"location":"tutorials/application-client/vue/#understanding-the-code","title":"Understanding the code","text":"<p>This Vue project has been generated using the Vue CLI tool. You may come across various configuration files and other items that are not essential for this tutorial. Our focus will be on the key files located within the <code>src/</code> directory:</p> <ul> <li> <p><code>App.vue</code>: This file defines the main application component along with its HTML template and styles. It is responsible for handling tasks such as joining a video call and managing the video calls themselves.</p> </li> <li> <p><code>VideoComponent.vue</code>: This file defines the <code>VideoComponent</code>. This component is responsible for displaying video tracks along with participant's data.</p> </li> <li><code>AudioComponent.vue</code>: This file defines the <code>AudioComponent</code>. This component is responsible for displaying audio tracks.</li> </ul> <p>To use the LiveKit JS SDK in a Vue application, you need to install the <code>livekit-client</code> package. This package provides the necessary classes and methods to interact with the LiveKit server. You can install it using the following command:</p> <pre><code>npm install livekit-client\n</code></pre> <p>Now let's see the code of the <code>App.vue</code> file:</p> App.vue<pre><code>type TrackInfo = {\n    // (1)!\n    trackPublication: RemoteTrackPublication;\n    participantIdentity: string;\n};\n\n// When running OpenVidu locally, leave these variables empty\n// For other deployment type, configure them with correct URLs depending on your deployment\nlet APPLICATION_SERVER_URL = \"\"; // (2)!\nlet LIVEKIT_URL = \"\"; // (3)!\nconfigureUrls();\n\nfunction configureUrls() {\n    // If APPLICATION_SERVER_URL is not configured, use default value from OpenVidu Local deployment\n    if (!APPLICATION_SERVER_URL) {\n        if (window.location.hostname === \"localhost\") {\n            APPLICATION_SERVER_URL = \"http://localhost:6080/\";\n        } else {\n            APPLICATION_SERVER_URL = \"https://\" + window.location.hostname + \":6443/\";\n        }\n    }\n\n    // If LIVEKIT_URL is not configured, use default value from OpenVidu Local deployment\n    if (!LIVEKIT_URL) {\n        if (window.location.hostname === \"localhost\") {\n            LIVEKIT_URL = \"ws://localhost:7880/\";\n        } else {\n            LIVEKIT_URL = \"wss://\" + window.location.hostname + \":7443/\";\n        }\n    }\n}\n\nconst room = ref&lt;Room&gt;(); // (4)!\nconst localTrack = ref&lt;LocalVideoTrack&gt;(); // (5)!\nconst remoteTracksMap: Ref&lt;Map&lt;string, TrackInfo&gt;&gt; = ref(new Map()); // (6)!\n\nlet participantName = ref(\"Participant\" + Math.floor(Math.random() * 100)); // (7)!\nlet roomName = ref(\"Test Room\"); // (8)!\n</code></pre> <ol> <li><code>TrackInfo</code> type, which groups a track publication with the participant's identity.</li> <li>The URL of the application server.</li> <li>The URL of the LiveKit server.</li> <li>The room object, which represents the video call room.</li> <li>The local video track, which represents the user's camera.</li> <li>Map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> <li>The participant's name.</li> <li>The room name.</li> </ol> <p>The <code>App.vue</code> file defines the following variables:</p> <ul> <li><code>APPLICATION_SERVER_URL</code>: The URL of the application server. This variable is used to make requests to the server to obtain a token for joining the video call room.</li> <li><code>LIVEKIT_URL</code>: The URL of the LiveKit server. This variable is used to connect to the LiveKit server and interact with the video call room.</li> <li><code>room</code>: The room object, which represents the video call room.</li> <li><code>localTrack</code>: The local video track, which represents the user's camera.</li> <li><code>remoteTracksMap</code>: A map that links track SIDs with <code>TrackInfo</code> objects. This map is used to store remote tracks and their associated participant identities.</li> <li><code>participantName</code>: The participant's name.</li> <li><code>roomName</code>: The room name.</li> </ul> <p>Configure the URLs</p> <p>When running OpenVidu locally, leave <code>APPLICATION_SERVER_URL</code> and <code>LIVEKIT_URL</code> variables empty. The function <code>configureUrls()</code> will automatically configure them with default values. However, for other deployment type, you should configure these variables with the correct URLs depending on your deployment.</p>"},{"location":"tutorials/application-client/vue/#joining-a-room","title":"Joining a Room","text":"<p>After the user specifies their participant name and the name of the room they want to join, when they click the <code>Join</code> button, the <code>joinRoom()</code> function is called:</p> App.vue<pre><code>async function joinRoom() {\n    // Initialize a new Room object\n    room.value = new Room(); // (1)!\n\n    // Specify the actions when events take place in the room\n    // On every new Track received...\n    room.value.on(\n        RoomEvent.TrackSubscribed,\n        (_track: RemoteTrack, publication: RemoteTrackPublication, participant: RemoteParticipant) =&gt; {\n            // (2)!\n            remoteTracksMap.value.set(publication.trackSid, {\n                trackPublication: publication,\n                participantIdentity: participant.identity\n            });\n        }\n    );\n\n    // On every Track destroyed...\n    room.value.on(RoomEvent.TrackUnsubscribed, (_track: RemoteTrack, publication: RemoteTrackPublication) =&gt; {\n        // (3)!\n        remoteTracksMap.value.delete(publication.trackSid);\n    });\n\n    try {\n        // Get a token from your application server with the room name and participant name\n        const token = await getToken(roomName.value, participantName.value); // (4)!\n\n        // Connect to the room with the LiveKit URL and the token\n        await room.value.connect(LIVEKIT_URL, token); // (5)!\n\n        // Publish your camera and microphone\n        await room.value.localParticipant.enableCameraAndMicrophone(); // (6)!\n        localTrack.value = room.value.localParticipant.videoTrackPublications.values().next().value.videoTrack;\n    } catch (error: any) {\n        console.log(\"There was an error connecting to the room:\", error.message);\n        await leaveRoom();\n    }\n\n    // Add listener for beforeunload event to leave the room when the user closes the tab\n    window.addEventListener(\"beforeunload\", leaveRoom); // (7)!\n}\n</code></pre> <ol> <li>Initialize a new <code>Room</code> object.</li> <li>Event handling for when a new track is received in the room.</li> <li>Event handling for when a track is destroyed.</li> <li>Get a token from the application server with the room name and participant name from the form.</li> <li>Connect to the room with the LiveKit URL and the token.</li> <li>Publish your camera and microphone.</li> <li>Add a listener for the <code>beforeunload</code> event to leave the room when the user closes the tab.</li> </ol> <p>The <code>joinRoom()</code> function performs the following actions:</p> <ol> <li> <p>It creates a new <code>Room</code> object. This object represents the video call room.</p> <p>Info</p> <p>When the room object is defined, the HTML template is automatically updated hiding the \"Join room\" page and showing the \"Room\" layout.</p> </li> <li> <p>Event handling is configured for different scenarios within the room. These events are fired when new tracks are subscribed to and when existing tracks are unsubscribed.</p> <ul> <li> <p><code>RoomEvent.TrackSubscribed</code>: This event is triggered when a new track is received in the room. It manages the storage of the new track in the <code>remoteTracksMap</code>, which links track SIDs with <code>TrackInfo</code> objects containing the track publication and the participant's identity.</p> </li> <li> <p><code>RoomEvent.TrackUnsubscribed</code>: This event occurs when a track is destroyed, and it takes care of removing the track from the <code>remoteTracksMap</code>.</p> </li> </ul> <p>These event handlers are essential for managing the behavior of tracks within the video call. You can further extend the event handling as needed for your application.</p> <p>Take a look at all events</p> <p>You can take a look at all the events in the Livekit Documentation</p> </li> <li> <p>It requests a token from the application server using the room name and participant name. This is done by calling the <code>getToken()</code> function:</p> App.vue<pre><code>/**\n * --------------------------------------------\n * GETTING A TOKEN FROM YOUR APPLICATION SERVER\n * --------------------------------------------\n * The method below request the creation of a token to\n * your application server. This prevents the need to expose\n * your LiveKit API key and secret to the client side.\n *\n * In this sample code, there is no user control at all. Anybody could\n * access your application server endpoints. In a real production\n * environment, your application server must identify the user to allow\n * access to the endpoints.\n */\nasync function getToken(roomName: string, participantName: string) {\n    const response = await fetch(APPLICATION_SERVER_URL + \"token\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            roomName,\n            participantName\n        })\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(`Failed to get token: ${error.errorMessage}`);\n    }\n\n    const data = await response.json();\n    return data.token;\n}\n</code></pre> <p>This function sends a POST request using <code>fetch()</code> to the application server's <code>/token</code> endpoint. The request body contains the room name and participant name. The server responds with a token that is used to connect to the room.</p> </li> <li> <p>It connects to the room using the LiveKit URL and the token.</p> </li> <li>It publishes the camera and microphone tracks to the room using <code>room.localParticipant.enableCameraAndMicrophone()</code>, which asks the user for permission to access their camera and microphone at the same time. The local video track is then stored in the <code>localTrack</code> variable.</li> <li>It adds a listener for the <code>beforeunload</code> event to leave the room when the user closes the tab.</li> </ol>"},{"location":"tutorials/application-client/vue/#displaying-video-and-audio-tracks","title":"Displaying Video and Audio Tracks","text":"<p>In order to display participants' video and audio tracks, the main component integrates the <code>VideoComponent</code> and <code>AudioComponent</code>.</p> App.vue<pre><code>&lt;div id=\"layout-container\"&gt;\n    &lt;VideoComponent v-if=\"localTrack\" :track=\"localTrack\" :participantIdentity=\"participantName\" :local=\"true\" /&gt;\n    &lt;template v-for=\"remoteTrack of remoteTracksMap.values()\" :key=\"remoteTrack.trackPublication.trackSid\"&gt;\n        &lt;VideoComponent\n            v-if=\"remoteTrack.trackPublication.kind === 'video'\"\n            :track=\"remoteTrack.trackPublication.videoTrack!\"\n            :participantIdentity=\"remoteTrack.participantIdentity\"\n        /&gt;\n        &lt;AudioComponent v-else :track=\"remoteTrack.trackPublication.audioTrack!\" hidden /&gt;\n    &lt;/template&gt;\n&lt;/div&gt;\n</code></pre> <p>This code snippet does the following:</p> <ul> <li> <p>We use the <code>v-if</code> directive to conditionally display the local video track using the <code>VideoComponent</code>. The <code>local</code> property is set to <code>true</code> to indicate that the video track belongs to the local participant.</p> <p>Info</p> <p>The audio track is not displayed for the local participant because there is no need to hear one's own audio.</p> </li> <li> <p>Then, we use the <code>v-for</code> directive to iterate over the <code>remoteTracksMap</code>. For each remote track, we create a <code>VideoComponent</code> or an <code>AudioComponent</code> depending on the track's kind (video or audio). The <code>participantIdentity</code> property is set to the participant's identity, and the <code>track</code> property is set to the video or audio track. The <code>hidden</code> attribute is added to the <code>AudioComponent</code> to hide the audio tracks from the layout.</p> </li> </ul> <p>Let's see now the code of the <code>VideoComponent.vue</code> file:</p> VideoComponent.vue<pre><code>const props = withDefaults(\n    defineProps&lt;{\n        track: LocalVideoTrack | RemoteVideoTrack; // (1)!\n        participantIdentity: string; // (2)!\n        local?: boolean; // (3)!\n    }&gt;(),\n    {\n        local: false\n    }\n);\n\nconst videoElement = ref&lt;HTMLMediaElement | null&gt;(null); // (4)!\n\nonMounted(() =&gt; {\n    if (videoElement.value) {\n        props.track.attach(videoElement.value); // (5)!\n    }\n});\n\nonUnmounted(() =&gt; {\n    props.track.detach(); // (6)!\n});\n</code></pre> <ol> <li>The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li>The participant identity associated with the video track.</li> <li>A boolean flag that indicates whether the video track belongs to the local participant.</li> <li>The reference to the video element in the HTML template.</li> <li>Attach the video track to the video element when the component is mounted.</li> <li>Detach the video track when the component is unmounted.</li> </ol> <p>The <code>VideoComponent</code> does the following:</p> <ul> <li> <p>It defines the properties <code>track</code>, <code>participantIdentity</code>, and <code>local</code> using the <code>defineProps()</code> function:</p> <ul> <li><code>track</code>: The video track object, which can be a <code>LocalVideoTrack</code> or a <code>RemoteVideoTrack</code>.</li> <li><code>participantIdentity</code>: The participant identity associated with the video track.</li> <li><code>local</code>: A boolean flag that indicates whether the video track belongs to the local participant. This flag is set to <code>false</code> by default.</li> </ul> </li> <li> <p>It creates a reference to the video element in the HTML template.</p> </li> <li>It attaches the video track to the video element when the component is mounted.</li> <li>It detaches the video track when the component is unmounted.</li> </ul> <p>Finally, let's see the code of the <code>AudioComponent.vue</code> file:</p> AudioComponent.vue<pre><code>const props = defineProps&lt;{\n    track: LocalAudioTrack | RemoteAudioTrack; // (1)!\n}&gt;();\nconst audioElement = ref&lt;HTMLMediaElement | null&gt;(null); // (2)!\n\nonMounted(() =&gt; {\n    if (audioElement.value) {\n        props.track.attach(audioElement.value); // (3)!\n    }\n});\n\nonUnmounted(() =&gt; {\n    props.track.detach(); // (4)!\n});\n</code></pre> <ol> <li>The audio track object, which can be a <code>LocalAudioTrack</code> or a <code>RemoteAudioTrack</code>, although in this case, it will always be a <code>RemoteAudioTrack</code>.</li> <li>The reference to the audio element in the HTML template.</li> <li>Attach the audio track to the audio element when the component is mounted.</li> <li>Detach the audio track when the component is unmounted.</li> </ol> <p>The <code>AudioComponent</code> is similar to the <code>VideoComponent</code> but is used to display audio tracks. It defines the <code>track</code> property using the <code>defineProps()</code> function and creates a reference to the audio element in the HTML template. The audio track is attached to the audio element when the component is mounted and detached when the component is unmounted.</p>"},{"location":"tutorials/application-client/vue/#leaving-the-room","title":"Leaving the Room","text":"<p>When the user wants to leave the room, they can click the <code>Leave Room</code> button. This action calls the <code>leaveRoom()</code> function:</p> App.vue<pre><code>async function leaveRoom() {\n    // Leave the room by calling 'disconnect' method over the Room object\n    await room.value?.disconnect(); // (1)!\n\n    // Empty all variables\n    room.value = undefined; // (2)!\n    localTrack.value = undefined;\n    remoteTracksMap.value.clear();\n\n    window.removeEventListener(\"beforeunload\", leaveRoom); // (3)!\n}\n\nonUnmounted(() =&gt; {\n    // (4)!\n    // On component unmount, leave the room\n    leaveRoom();\n});\n</code></pre> <ol> <li>Disconnect the user from the room.</li> <li>Reset all variables to their initial state.</li> <li>Remove the <code>beforeunload</code> event listener.</li> <li>Call the <code>leaveRoom()</code> function when the component is unmounted.</li> </ol> <p>The <code>leaveRoom()</code> function performs the following actions:</p> <ul> <li>It disconnects the user from the room by calling the <code>disconnect()</code> method on the <code>Room</code> object.</li> <li>It resets all variables to their initial state.</li> <li>It removes the <code>beforeunload</code> event listener.</li> </ul> <p>The <code>leaveRoom()</code> function is also called when the component is unmounted using the <code>onUnmounted()</code> lifecycle hook. This ensures that the user leaves the room when the component is no longer needed.</p>"},{"location":"tutorials/application-server/","title":"Application Server Tutorials","text":"<p>Every application server below has two specific purposes: </p> <ul> <li>Generate LiveKit tokens on demand for any application client.</li> <li>Receive LiveKit webhook events.</li> </ul> <p>To do so they all define two REST endpoints:</p> <ul> <li><code>/token</code>: takes a room and participant name and returns a token.</li> <li><code>/webhook</code>: for receiving webhook events from LiveKit Server.</li> </ul> <p>They use the proper LiveKit Server SDK for their language, if available.</p> <p> Node.js</p> <p> Go</p> <p> Ruby</p> <p> Java</p> <p> Python</p> <p> Rust</p> <p> PHP</p> <p> .NET</p>"},{"location":"tutorials/application-server/dotnet/","title":".NET Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for .NET with ASP.NET Core Minimal APIs that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses the LiveKit .NET SDK.</p>"},{"location":"tutorials/application-server/dotnet/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/dotnet/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/dotnet/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/dotnet/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need .NET installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/dotnet\n</code></pre></li> <li>Run the application <pre><code>dotnet run\n</code></pre></li> </ol> <p>Warning</p> <p>This .NET server application needs the <code>LIVEKIT_API_SECRET</code> env variable to be at least 32 characters long. Make sure to update it here and in your LiveKit Server.</p>"},{"location":"tutorials/application-server/dotnet/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/dotnet/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple ASP.NET Core Minimal APIs app with a single file <code>Program.cs</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code <code>Program.cs</code> file:</p> Program.cs<pre><code>using System.Text.Json;\nusing Livekit.Server.Sdk.Dotnet; // (1)!\n\nvar builder = WebApplication.CreateBuilder(args); // (2)!\nvar MyAllowSpecificOrigins = \"_myAllowSpecificOrigins\"; // (3)!\n\nIConfiguration config = new ConfigurationBuilder() // (4)!\n    .SetBasePath(Directory.GetCurrentDirectory())\n    .AddJsonFile(\"appsettings.json\")\n    .AddEnvironmentVariables()\n    .Build();\n\n// Load env variables\nvar SERVER_PORT = config.GetValue&lt;int&gt;(\"SERVER_PORT\"); // (5)!\nvar LIVEKIT_API_KEY = config.GetValue&lt;string&gt;(\"LIVEKIT_API_KEY\"); // (6)!\nvar LIVEKIT_API_SECRET = config.GetValue&lt;string&gt;(\"LIVEKIT_API_SECRET\"); // (7)!\n\n// Enable CORS support\nbuilder.Services.AddCors(options =&gt; // (8)!\n{\n    options.AddPolicy(\n        name: MyAllowSpecificOrigins,\n        builder =&gt;\n        {\n            builder.WithOrigins(\"*\").AllowAnyHeader();\n        }\n    );\n});\n\nbuilder.WebHost.UseKestrel(serverOptions =&gt; // (9)!\n{\n    serverOptions.ListenAnyIP(SERVER_PORT);\n});\n\nvar app = builder.Build(); // (10)!\napp.UseCors(MyAllowSpecificOrigins);\n</code></pre> <ol> <li>Import the LiveKit .NET SDK.</li> <li>A <code>WebApplicationBuilder</code> instance to build the application.</li> <li>The name of the CORS policy to be used in the application.</li> <li>A <code>IConfiguration</code> instance to load the configuration from the <code>appsettings.json</code> file, including the required environment variables.</li> <li>The port where the application will be listening.</li> <li>The API key of LiveKit Server.</li> <li>The API secret of LiveKit Server.</li> <li>Configure CORS support.</li> <li>Configure the port.</li> <li>Build the application and enable CORS support.</li> </ol> <p>The <code>Program.cs</code> file imports the required dependencies and loads the necessary environment variables (defined in <code>appsettings.json</code> file):</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Finally the application enables CORS support and the port where the application will be listening.</p>"},{"location":"tutorials/application-server/dotnet/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> Program.cs<pre><code>app.MapPost(\n    \"/token\",\n    async (HttpRequest request) =&gt;\n    {\n        var body = new StreamReader(request.Body); // (1)!\n        string postData = await body.ReadToEndAsync();\n        Dictionary&lt;string, dynamic&gt; bodyParams =\n            JsonSerializer.Deserialize&lt;Dictionary&lt;string, dynamic&gt;&gt;(postData)\n            ?? new Dictionary&lt;string, dynamic&gt;();\n\n        if (\n            bodyParams.TryGetValue(\"roomName\", out var roomName)\n            &amp;&amp; bodyParams.TryGetValue(\"participantName\", out var participantName)\n        )\n        {\n            var token = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET) // (2)!\n                .WithIdentity(participantName.ToString()) // (3)!\n                .WithName(participantName.ToString())\n                .WithGrants(new VideoGrants{ RoomJoin = true, Room = roomName.ToString() }); // (4)!\n\n            var jwt = token.ToJwt(); // (5)!\n            return Results.Json(new { token = jwt }); // (6)!\n        }\n        else\n        {\n            return Results.BadRequest(\n                new { errorMessage = \"roomName and participantName are required\" } // (7)!\n            );\n        }\n    }\n);\n</code></pre> <ol> <li>The endpoint obtains a Dictionary from the body request, and check if fields <code>roomName</code> and <code>participantName</code> are available.</li> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>RoomName</code> determines the specific room. Check out all Video Grants.</li> <li>Obtain the JWT string from the AccessToken.</li> <li>Return the token to the client.</li> <li>Return a <code>400</code> error if required fields are not available.</li> </ol> <p>The endpoint obtains a Dictionary from the body request, and check if fields <code>roomName</code> and <code>participantName</code> are available. If not, it returns a <code>400</code> error. If required fields are available, a new <code>AccessToken</code> is created with the proper participant's identity, name and video grants. The <code>RoomJoin</code> grant allows the user to join a room and the <code>Room</code> grant determines the specific room. Check out all Video Grants.</p> <p>Finally, the returned token is sent back to the client.</p>"},{"location":"tutorials/application-server/dotnet/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> Program.cs<pre><code>app.MapPost(\n    \"/livekit/webhook\",\n    async (HttpRequest request) =&gt;\n    {\n        var webhookReceiver = new WebhookReceiver(LIVEKIT_API_KEY, LIVEKIT_API_SECRET); // (1)!\n        try\n        {\n            StreamReader body = new StreamReader(request.Body); // (2)!\n            string postData = await body.ReadToEndAsync();\n            string authHeader =\n                request.Headers[\"Authorization\"].FirstOrDefault() // (3)!\n                ?? throw new Exception(\"Authorization header is missing\");\n\n            WebhookEvent webhookEvent = webhookReceiver.Receive(postData, authHeader); // (4)!\n\n            Console.Out.WriteLine(webhookEvent); // (5)!\n\n            return Results.Ok(); // (6)!\n        }\n        catch (Exception e)\n        {\n            Console.Error.WriteLine(\"Error validating webhook event: \" + e.Message); // (7)!\n            return Results.Unauthorized();\n        }\n    }\n);\n</code></pre> <ol> <li>Initialize the WebhookReceiver using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. It will help validating and decoding incoming webhook events.</li> <li>The raw string body of the request contains the webhook event.</li> <li>The <code>Authorization</code> header is required to validate the webhook event.</li> <li>Obtain the <code>WebhookEvent</code> object using the <code>WebhookReceiver#Receive</code> method. It takes the raw body as a String and the Authorization header of the request.</li> <li>Consume the event as you whish.</li> <li>Return a response to LiveKit Server to let it know that the webhook was received correctly.</li> <li>You can handle any exception triggered by the validation process.</li> </ol> <p>We first initialize a <code>WebhookReceiver</code> object using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</p> <p>Then we need the raw body as a String and the <code>Authorization</code> header of the request. With them we obtain a <code>WebhookEvent</code> object calling method <code>WebhookReceiver#Receive</code>. If everything is correct, you can do whatever you want with the event (in this case, we just log it).</p> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"},{"location":"tutorials/application-server/go/","title":"Go Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Go with Gin  that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses the LiveKit Go SDK.</p>"},{"location":"tutorials/application-server/go/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/go/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/go/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/go/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need Go installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/go\n</code></pre></li> <li>Run the application <pre><code>go run main.go\n</code></pre></li> </ol>"},{"location":"tutorials/application-server/go/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/go/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Go app with a single file <code>main.go</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>main.go</code> file:</p> main.go<pre><code>var SERVER_PORT string // (1)!\nvar LIVEKIT_API_KEY string // (2)!\nvar LIVEKIT_API_SECRET string // (3)!\n</code></pre> <ol> <li>The port where the application will be listening</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> </ol> <p>The <code>main.go</code> file first declares the necessary global variables:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>The server launch takes place in the <code>main</code> function at the end of the file, where we first load the environment variables, then set the REST endpoints and finally start the server on <code>SERVER_PORT</code>:</p> main.go<pre><code>func main() {\n    loadEnv() // (1)!\n    router := gin.Default() // (2)!\n    router.Use(cors.Default()) // (3)!\n    router.POST(\"/token\", createToken) // (4)!\n    router.POST(\"/livekit/webhook\", receiveWebhook) // (5)!\n    router.Run(\":\" + SERVER_PORT) // (6)!\n}\n</code></pre> <ol> <li>Load environment variables</li> <li>Create a new Gin router</li> <li>Enable CORS support</li> <li>Create the <code>/token</code> endpoint</li> <li>Create the <code>/livekit/webhook</code> endpoint</li> <li>Start the server on the <code>SERVER_PORT</code></li> </ol>"},{"location":"tutorials/application-server/go/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> main.go<pre><code>func createToken(context *gin.Context) {\n    var body struct {\n        RoomName        string `json:\"roomName\"`\n        ParticipantName string `json:\"participantName\"`\n    }\n\n    if err := context.BindJSON(&amp;body); err != nil {\n        context.JSON(http.StatusBadRequest, err.Error())\n        return\n    }\n\n    if body.RoomName == \"\" || body.ParticipantName == \"\" {\n        context.JSON(http.StatusBadRequest, gin.H{\"errorMessage\": \"roomName and participantName are required\"})\n        return\n    }\n\n    at := auth.NewAccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET) // (1)!\n    grant := &amp;auth.VideoGrant{\n        RoomJoin: true,\n        Room:     body.RoomName,\n    }\n    at.SetVideoGrant(grant).SetIdentity(body.ParticipantName) // (2)!\n\n    token, err := at.ToJWT() // (3)!\n    if err != nil {\n        context.JSON(http.StatusInternalServerError, err.Error())\n        return\n    }\n\n    context.JSON(http.StatusOK, gin.H{\"token\": token}) // (4)!\n}\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set the video grants and identity of the participant in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>Room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>We first load the request body into a struct with <code>roomName</code> and <code>participantName</code> string fields. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Go SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set the video grants and identity of the participant in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>Room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token and return it to the client.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"tutorials/application-server/go/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> main.go<pre><code>func receiveWebhook(context *gin.Context) {\n    authProvider := auth.NewSimpleKeyProvider( // (1)!\n        LIVEKIT_API_KEY, LIVEKIT_API_SECRET,\n    )\n    event, err := webhook.ReceiveWebhookEvent(context.Request, authProvider) // (2)!\n    if err != nil {\n        fmt.Fprintf(os.Stderr, \"error validating webhook event: %v\", err)\n        return\n    }\n    fmt.Println(\"LiveKit Webhook\", event) // (3)!\n}\n</code></pre> <ol> <li>Create a <code>SimpleKeyProvider</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API</code>.</li> <li>Receive the webhook event providing the <code>http.Request</code> in the Gin context and the <code>SimpleKeyProvider</code> we just created. This will validate and decode the incoming webhook event.</li> <li>Consume the event as you whish.</li> </ol> <p></p> <ol> <li>Create a <code>SimpleKeyProvider</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API</code>.</li> <li>Receive the webhook event providing the <code>http.Request</code> in the Gin context and the <code>SimpleKeyProvider</code> we just created. This will validate and decode the incoming webhook event.</li> <li>Consume the event as you whish.</li> </ol> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"},{"location":"tutorials/application-server/java/","title":"Java Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Java with Spring Boot that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit Kotlin SDK.</p>"},{"location":"tutorials/application-server/java/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/java/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/java/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/java/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need Java and Maven installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/java\n</code></pre></li> <li>Run the application <pre><code>mvn spring-boot:run\n</code></pre></li> </ol>"},{"location":"tutorials/application-server/java/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/java/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Spring Boot app with a single controller <code>Controller.java</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>Controller.java</code> file:</p> Controller.java<pre><code>@CrossOrigin(origins = \"*\") // (1)!\n@RestController // (2)!\npublic class Controller {\n\n    @Value(\"${livekit.api.key}\")\n    private String LIVEKIT_API_KEY; // (3)!\n\n    @Value(\"${livekit.api.secret}\")\n    private String LIVEKIT_API_SECRET; // (4)!\n\n    ...\n}\n</code></pre> <ol> <li>Allows the application to be accessed from any domain</li> <li>Marks the class as a controller where every method returns a domain object instead of a view</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> </ol> <p>Starting by the top, the <code>Controller</code> class has the following annotations:</p> <ul> <li><code>@CrossOrigin(origins = \"*\")</code>: allows the application to be accessed from any domain.</li> <li><code>@RestController</code>: marks the class as a controller where every method returns a domain object instead of a view.</li> </ul> <p>Going deeper, the <code>Controller</code> class has the following fields:</p> <ul> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server. It is injected from the property <code>livekit.api.key</code> defined in <code>application.properties</code> using the <code>@Value(\"${livekit.api.key}\")</code> annotation.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server. It is injected from the the property <code>livekit.api.secret</code> defined in <code>application.properties</code> using the <code>@Value(\"${livekit.api.secret}\")</code> annotation.</li> </ul>"},{"location":"tutorials/application-server/java/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> Controller.java<pre><code>@PostMapping(value = \"/token\")\npublic ResponseEntity&lt;Map&lt;String, String&gt;&gt; createToken(@RequestBody Map&lt;String, String&gt; params) {\n    String roomName = params.get(\"roomName\");\n    String participantName = params.get(\"participantName\");\n\n    if (roomName == null || participantName == null) {\n        return ResponseEntity.badRequest().body(Map.of(\"errorMessage\", \"roomName and participantName are required\"));\n    }\n\n    AccessToken token = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET); // (1)!\n    token.setName(participantName); // (2)!\n    token.setIdentity(participantName);\n    token.addGrants(new RoomJoin(true), new RoomName(roomName)); // (3)!\n\n    return ResponseEntity.ok(Map.of(\"token\", token.toJwt())); // (4)!\n}\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>RoomName</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Kotlin SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>RoomJoin</code> allows the user to join a room and <code>RoomName</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"tutorials/application-server/java/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> Controller.java<pre><code>@PostMapping(value = \"/livekit/webhook\", consumes = \"application/webhook+json\")\npublic ResponseEntity&lt;String&gt; receiveWebhook(@RequestHeader(\"Authorization\") String authHeader, @RequestBody String body) { // (1)!\n    WebhookReceiver webhookReceiver = new WebhookReceiver(LIVEKIT_API_KEY, LIVEKIT_API_SECRET); // (2)!\n    try {\n        WebhookEvent event = webhookReceiver.receive(body, authHeader); // (3)!\n        System.out.println(\"LiveKit Webhook: \" + event.toString()); // (4)!\n    } catch (Exception e) {\n        System.err.println(\"Error validating webhook event: \" + e.getMessage());\n    }\n    return ResponseEntity.ok(\"ok\");\n}\n</code></pre> <ol> <li>We need the 'Authorization' header and the raw body of the HTTP request.</li> <li>Initialize the WebhookReceiver using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. It will help validating and decoding incoming webhook events.</li> <li>Obtain the <code>WebhookEvent</code> object using the <code>WebhookReceiver#receive</code> method. It takes the raw body as a String and the Authorization header of the request.</li> <li>Consume the event as you whish.</li> </ol> <p>We declare the 'Authorization' header and the raw body of the HTTP request as parameters of the our method. We need both of them to validate and decode the incoming webhook event.</p> <p>Then we initialize a <code>WebhookReceiver</code> object using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</p> <p>Finally we obtain a <code>WebhookEvent</code> object calling method <code>WebhookReceiver#receive</code>. It takes the raw body as a String and the <code>Authorization</code> header of the request. If everything is correct, you can do whatever you want with the event (in this case, we just log it).</p> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"},{"location":"tutorials/application-server/node/","title":"Node.js Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Node.js with Express that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit JS SDK.</p>"},{"location":"tutorials/application-server/node/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/node/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/node/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/node/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need Node.js installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/node\n</code></pre></li> <li>Install dependencies <pre><code>npm install\n</code></pre></li> <li>Run the application <pre><code>npm start\n</code></pre></li> </ol>"},{"location":"tutorials/application-server/node/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/node/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Express app with a single file <code>index.js</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>index.js</code> file:</p> index.js<pre><code>import \"dotenv/config\";\nimport express from \"express\";\nimport cors from \"cors\";\nimport { AccessToken, WebhookReceiver } from \"livekit-server-sdk\"; // (1)!\n\nconst SERVER_PORT = process.env.SERVER_PORT || 6080; // (2)!\nconst LIVEKIT_API_KEY = process.env.LIVEKIT_API_KEY || \"devkey\"; // (3)!\nconst LIVEKIT_API_SECRET = process.env.LIVEKIT_API_SECRET || \"secret\"; // (4)!\n\nconst app = express(); // (5)!\n\napp.use(cors()); // (6)!\napp.use(express.json()); // (7)!\napp.use(express.raw({ type: \"application/webhook+json\" })); // (8)!\n</code></pre> <ol> <li>Import <code>AccessToken</code> from <code>livekit-server-sdk</code>.</li> <li>The port where the application will be listening.</li> <li>The API key of LiveKit Server.</li> <li>The API secret of LiveKit Server.</li> <li>Initialize the Express application.</li> <li>Enable CORS support.</li> <li>Enable JSON body parsing for the <code>/token</code> endpoint.</li> <li>Enable raw body parsing for the <code>/livekit/webhook</code> endpoint.</li> </ol> <p>The <code>index.js</code> file imports the required dependencies and loads the necessary environment variables:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Finally the <code>express</code> application is initialized. CORS is allowed, JSON body parsing is enabled for the <code>/token</code> endpoint and raw body parsing is enabled for the <code>/livekit/webhook</code> endpoint.</p>"},{"location":"tutorials/application-server/node/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> index.js<pre><code>app.post(\"/token\", async (req, res) =&gt; {\n  const roomName = req.body.roomName;\n  const participantName = req.body.participantName;\n\n  if (!roomName || !participantName) {\n    res.status(400).json({ errorMessage: \"roomName and participantName are required\" });\n    return;\n  }\n\n  const at = new AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET, { // (1)!\n    identity: participantName,\n  });\n  at.addGrant({ roomJoin: true, room: roomName }); // (2)!\n  const token = await at.toJwt(); // (3)!\n  res.json({ token }); // (4)!\n});\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code>, <code>LIVEKIT_API_SECRET</code> and setting the participant's identity.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit JS SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code>, <code>LIVEKIT_API_SECRET</code> and setting the participant's identity.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"tutorials/application-server/node/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> index.js<pre><code>const webhookReceiver = new WebhookReceiver( // (1)!\n  LIVEKIT_API_KEY,\n  LIVEKIT_API_SECRET\n);\n\napp.post(\"/livekit/webhook\", async (req, res) =&gt; {\n  try {\n    const event = await webhookReceiver.receive(\n      req.body, // (2)!\n      req.get(\"Authorization\") // (3)!\n    );\n    console.log(event); // (4)!\n  } catch (error) {\n    console.error(\"Error validating webhook event\", error);\n  }\n  res.status(200).send();\n});\n</code></pre> <ol> <li>Initialize the WebhookReceiver using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. It will help validating and decoding incoming webhook events.</li> <li>The body of the HTTP request.</li> <li>The <code>Authorization</code> header of the HTTP request.</li> <li>Consume the event as you whish.</li> </ol> <p>First of all we initialize the <code>WebhookReceiver</code> using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This object will validate and decode the incoming webhook events.</p> <p>The endpoint receives the incoming webhook with the async method <code>WebhookReceiver#receive</code>. It takes the body and the <code>Authorization</code> header of the request. If everything is correct, you can do whatever you want with the event (in this case, we just log it).</p> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"},{"location":"tutorials/application-server/php/","title":"PHP Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for PHP  that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit PHP SDK.</p>"},{"location":"tutorials/application-server/php/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/php/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/php/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/php/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need PHP and Composer installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/php\n</code></pre></li> <li>Install dependencies <pre><code>composer install\n</code></pre></li> <li>Run the application <pre><code>composer start\n</code></pre></li> </ol> <p>Warning</p> <p>LiveKit PHP SDK requires library BCMath. This is available out-of-the-box in PHP for Windows, but a manual installation might be necessary in other OS. Run <code>sudo apt install php-bcmath</code> or <code>sudo yum install php-bcmath</code></p>"},{"location":"tutorials/application-server/php/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/php/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple PHP app with a single file <code>index.php</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>index.php</code> file:</p> index.php<pre><code>&lt;?php\nrequire __DIR__ . \"/vendor/autoload.php\";\n\nuse Agence104\\LiveKit\\AccessToken; // (1)!\nuse Agence104\\LiveKit\\AccessTokenOptions;\nuse Agence104\\LiveKit\\VideoGrant;\nuse Agence104\\LiveKit\\WebhookReceiver;\nuse Dotenv\\Dotenv;\n\nDotenv::createImmutable(__DIR__)-&gt;safeLoad();\n\nheader(\"Access-Control-Allow-Origin: *\"); // (2)!\nheader(\"Access-Control-Allow-Headers: Content-Type, Authorization\");\nheader(\"Content-type: application/json\");\n\n$LIVEKIT_API_KEY = $_ENV[\"LIVEKIT_API_KEY\"] ?? \"devkey\"; // (3)!\n$LIVEKIT_API_SECRET = $_ENV[\"LIVEKIT_API_SECRET\"] ?? \"secret\"; // (4)!\n</code></pre> <ol> <li>Import all necessary dependencies from the PHP LiveKit library.</li> <li>Configure HTTP headers for the web server: enable CORS support, allow the <code>Content-Type</code> and <code>Authorization</code> headers and set the response content type to <code>application/json</code>.</li> <li>The API key of LiveKit Server.</li> <li>The API secret of LiveKit Server.</li> </ol> <p>The <code>index.php</code> file imports the required dependencies, sets the HTTP headers for the web server and loads the necessary environment variables:</p> <ul> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul>"},{"location":"tutorials/application-server/php/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> index.php<pre><code>&lt;?php\nif (isset($_SERVER[\"REQUEST_METHOD\"]) &amp;&amp; $_SERVER[\"REQUEST_METHOD\"] === \"POST\" &amp;&amp; $_SERVER[\"PATH_INFO\"] === \"/token\") {\n    $data = json_decode(file_get_contents(\"php://input\"), true);\n\n    $roomName = $data[\"roomName\"] ?? null;\n    $participantName = $data[\"participantName\"] ?? null;\n\n    if (!$roomName || !$participantName) {\n        http_response_code(400);\n        echo json_encode([\"errorMessage\" =&gt; \"roomName and participantName are required\"]);\n        exit();\n    }\n\n    $tokenOptions = (new AccessTokenOptions()) // (1)!\n        -&gt;setIdentity($participantName);\n    $videoGrant = (new VideoGrant()) // (2)!\n        -&gt;setRoomJoin()\n        -&gt;setRoomName($roomName);\n    $token = (new AccessToken($LIVEKIT_API_KEY, $LIVEKIT_API_SECRET)) // (3)!\n        -&gt;init($tokenOptions)\n        -&gt;setGrant($videoGrant)\n        -&gt;toJwt();\n\n    echo json_encode([\"token\" =&gt; $token]); // (4)!\n    exit();\n}\n</code></pre> <ol> <li>Create an <code>AccessTokenOptions</code> object with the participant's identity.</li> <li>Create a <code>VideoGrant</code> object setting the necessary video grants options. <code>setRoomJoin</code> allows the user to join a room and <code>setRoomName</code> determines the specific room. Check out all Video Grants.</li> <li>We create the <code>AccessToken</code> providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>, initialize it with the token options, set the video grants and generate the JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit PHP SDK:</p> <ol> <li>Create an <code>AccessTokenOptions</code> object with the participant's identity.</li> <li>Create a <code>VideoGrant</code> object setting the necessary video grants options. <code>setRoomJoin</code> allows the user to join a room and <code>setRoomName</code> determines the specific room. Check out all Video Grants.</li> <li>We create the <code>AccessToken</code> providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>, initialize it with the token options, set the video grants and generate the JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"tutorials/application-server/php/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> index.php<pre><code>&lt;?php\n$webhookReceiver = (new WebhookReceiver($LIVEKIT_API_KEY, $LIVEKIT_API_SECRET)); // (1)!\n\nif (isset($_SERVER[\"REQUEST_METHOD\"]) &amp;&amp; $_SERVER[\"REQUEST_METHOD\"] === \"POST\" &amp;&amp; $_SERVER[\"PATH_INFO\"] === \"/livekit/webhook\") {\n    $headers = getallheaders();\n    $authHeader = $headers[\"Authorization\"]; // (2)!\n    $body = file_get_contents(\"php://input\"); // (3)!\n    try {\n        $event = $webhookReceiver-&gt;receive($body, $authHeader); // (4)!\n        error_log(\"LiveKit Webhook:\");\n        error_log(print_r($event-&gt;getEvent(), true)); // (5)!\n        exit();\n    } catch (Exception $e) {\n        http_response_code(401);\n        echo \"Error validating webhook event\";\n        echo json_encode($e-&gt;getMessage());\n        exit();\n    }\n}\n</code></pre> <ol> <li>Create a new <code>WebhookReceiver</code> object providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. It will help validating and decoding incoming webhook events.</li> <li>The <code>Authorization</code> header of the HTTP request.</li> <li>The raw body of the HTTP request as a string.</li> <li>Obtain the <code>WebhookEvent</code> object using the <code>WebhookReceiver#receive</code> method. It takes the raw body as a String and the Authorization header of the request.</li> <li>Consume the event as you wish.</li> </ol> <p>We first create a <code>WebhookReceiver</code> object using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. Then we must retrieve the <code>Authorization</code> header and the raw body of the HTTP request. We need both of them to validate and decode the incoming webhook event.</p> <p>Finally, we obtain the <code>WebhookEvent</code> object using the <code>WebhookReceiver#receive</code> method. It takes the raw body as a String and the Authorization header of the request. We can consume the event as we wish (in this case, we just log it using the error output).</p> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"},{"location":"tutorials/application-server/python/","title":"Python Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Python with Flask that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit Python SDK.</p>"},{"location":"tutorials/application-server/python/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/python/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/python/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/python/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need Python 3 installed on your device.</p> <ol> <li> <p>Navigate into the server directory</p> <pre><code>cd openvidu-livekit-tutorials/application-server/python\n</code></pre> </li> <li> <p>Create a python virtual environment</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the virtual environment</p>  Windows macOS Linux <pre><code>.\\venv\\Scripts\\activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> <pre><code>. ./venv/bin/activate\n</code></pre> </li> <li> <p>Install dependencies</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run the application</p> <pre><code>python app.py\n</code></pre> </li> </ol>"},{"location":"tutorials/application-server/python/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/python/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Flask app with a single file <code>app.py</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>app.py</code> file:</p> app.py<pre><code>import os\nfrom flask import Flask, request\nfrom flask_cors import CORS\nfrom dotenv import load_dotenv\nfrom livekit.api import AccessToken, VideoGrants, TokenVerifier, WebhookReceiver # (1)!\n\nload_dotenv() # (2)!\n\nSERVER_PORT = os.environ.get(\"SERVER_PORT\", 6080) # (3)!\nLIVEKIT_API_KEY = os.environ.get(\"LIVEKIT_API_KEY\", \"devkey\") # (4)!\nLIVEKIT_API_SECRET = os.environ.get(\"LIVEKIT_API_SECRET\", \"secret\") # (5)!\n\napp = Flask(__name__) # (6)!\n\nCORS(app) # (7)!\n</code></pre> <ol> <li>Import all necessary dependencies from <code>livekit</code> library</li> <li>Load environment variables from <code>.env</code> file</li> <li>The port where the application will be listening</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> <li>Initialize the Flask application</li> <li>Enable CORS support</li> </ol> <p>The <code>app.py</code> file imports the required dependencies and loads the necessary environment variables from <code>.env</code> file using <code>dotenv</code> library:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Finally the <code>Flask</code> application is initialized and CORS support is enabled.</p>"},{"location":"tutorials/application-server/python/#create-token","title":"Create token","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> app.py<pre><code>@app.post(\"/token\")\ndef create_token():\n    room_name = request.json.get(\"roomName\")\n    participant_name = request.json.get(\"participantName\")\n\n    if not room_name or not participant_name:\n        return {\"errorMessage\": \"roomName and participantName are required\"}, 400\n\n    token = (\n        AccessToken(LIVEKIT_API_KEY, LIVEKIT_API_SECRET) # (1)!\n        .with_identity(participant_name) # (2)!\n        .with_grants(api.VideoGrants(room_join=True, room=room_name)) # (3)!\n    )\n    return {\"token\": token.to_jwt()} # (4)!\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Python SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol>"},{"location":"tutorials/application-server/python/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> app.py<pre><code>token_verifier = TokenVerifier(LIVEKIT_API_KEY, LIVEKIT_API_SECRET) # (1)!\nwebhook_receiver = WebhookReceiver(token_verifier) # (2)!\n\n\n@app.post(\"/livekit/webhook\")\ndef receive_webhook():\n    auth_token = request.headers.get(\"Authorization\") # (3)!\n\n    if not auth_token:\n        return \"Authorization header is required\", 401\n\n    try:\n        event = webhook_receiver.receive(request.data.decode(\"utf-8\"), auth_token) # (4)!\n        print(\"LiveKit Webhook:\", event) # (5)!\n        return \"ok\"\n    except:\n        print(\"Authorization header is not valid\")\n        return \"Authorization header is not valid\", 401\n</code></pre> <ol> <li>Initialize a <code>TokenVerifier</code> using the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>Initialize a <code>WebhookReceiver</code> using the <code>TokenVerifier</code>. It will help validating and decoding incoming webhook events.</li> <li>Get the 'Authorization' header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw body of the request and the 'Authorization' header.</li> <li>Consume the event as you whish.</li> </ol> <p>First of all, we need a <code>WebhookReceiver</code> for validating and decoding incoming webhook events. We initialize it with a <code>TokenVerifier</code> built with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</p> <p>Inside the <code>receive_webhook</code> handler we:</p> <ol> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw body of the request and the <code>Authorization</code> header. In this way, we can validate the event to confirm it is actually coming from our LiveKit Server.</li> <li>If everything is ok, you can consume the event as you whish (in this case, we just log it).</li> </ol> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"},{"location":"tutorials/application-server/ruby/","title":"Ruby Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Ruby with Sinatra that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses LiveKit Ruby SDK.</p>"},{"location":"tutorials/application-server/ruby/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/ruby/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/ruby/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/ruby/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need Ruby installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/ruby\n</code></pre></li> <li>Install dependencies <pre><code>bundle install\n</code></pre></li> <li>Run the application <pre><code>ruby app.rb\n</code></pre></li> </ol>"},{"location":"tutorials/application-server/ruby/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/ruby/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Ruby app using the popular Sinatra web library. It has a single file <code>app.rb</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>app.rb</code> file:</p> app.rb<pre><code>require 'sinatra'\nrequire 'sinatra/cors'\nrequire 'sinatra/json'\nrequire 'livekit' # (1)!\nrequire './env.rb'\n\nSERVER_PORT = ENV['SERVER_PORT'] || 6080 # (2)!\nLIVEKIT_API_KEY = ENV['LIVEKIT_API_KEY'] || 'devkey' # (3)!\nLIVEKIT_API_SECRET = ENV['LIVEKIT_API_SECRET'] || 'secret' # (4)!\n\nset :port, SERVER_PORT # (5)!\n\nregister Sinatra::Cors # (6)!\nset :allow_origin, '*' # (7)!\nset :allow_methods, 'POST,OPTIONS'\nset :allow_headers, 'content-type'\nset :bind, '0.0.0.0' # (8)!\n</code></pre> <ol> <li>Import <code>livekit</code> library</li> <li>The port where the application will be listening</li> <li>The API key of LiveKit Server</li> <li>The API secret of LiveKit Server</li> <li>Configure the port</li> <li>Enable CORS support</li> <li>Set allowed origin (any), methods and headers</li> <li>Listen in any available network interface of the host</li> </ol> <p>The <code>app.rb</code> file imports the required dependencies and loads the necessary environment variables (defined in <code>env.rb</code> file):</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Finally the application configures the port, sets the CORS configuration for Sinatra and binds the application to all available network interfaces (0.0.0.0).</p>"},{"location":"tutorials/application-server/ruby/#create-token-endpoint","title":"Create token endpoint","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> app.rb<pre><code>post '/token' do\n  body = JSON.parse(request.body.read)\n  room_name = body['roomName']\n  participant_name = body['participantName']\n\n  if room_name.nil? || participant_name.nil?\n    status 400\n    return json({errorMessage: 'roomName and participantName are required'})\n  end\n\n  token = LiveKit::AccessToken.new(api_key: LIVEKIT_API_KEY, api_secret: LIVEKIT_API_SECRET) # (1)!\n  token.identity = participant_name # (2)!\n  token.add_grant(roomJoin: true, room: room_name) # (3)!\n\n  return json({token: token.to_jwt}) # (4)!\nend\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Ruby SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>roomJoin</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>Finally, we convert the AccessToken to a JWT token and send it back to the client.</li> </ol>"},{"location":"tutorials/application-server/ruby/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> app.rb<pre><code>post '/livekit/webhook' do\n  auth_header = request.env['HTTP_AUTHORIZATION'] # (1)!\n  token_verifier = LiveKit::TokenVerifier.new(api_key: LIVEKIT_API_KEY, api_secret: LIVEKIT_API_SECRET) # (2)!\n  begin\n    token_verifier.verify(auth_header) # (3)!\n    body = JSON.parse(request.body.read) # (4)!\n    puts \"LiveKit Webhook: #{body}\" # (5)!\n    return\n  rescue =&gt; e\n    puts \"Authorization header is not valid: #{e}\"\n  end\nend\n</code></pre> <ol> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Create a new <code>TokenVerifier</code> instance providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This will validate the webhook event to confirm it is actually coming from our LiveKit Server.</li> <li>Verify the <code>Authorization</code> header with the <code>TokenVerifier</code>.</li> <li>Now that we are sure the event is valid, we can parse the request JSON body to get the actual webhook event.</li> <li>Consume the event as you whish.</li> </ol> <p></p> <p>We need to verify that the event is coming from our LiveKit Server. For that we need the <code>Authorization</code> header from the HTTP request and a <code>TokenVerifier</code> instance built with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</p> <p>If the verification is successful, we can parse the request JSON body and consume the event (in this case, we just log it).</p> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"},{"location":"tutorials/application-server/rust/","title":"Rust Server Tutorial","text":"<p>Source code </p> <p>This is a minimal server application built for Rust with Axum that allows:</p> <ul> <li>Generating LiveKit tokens on demand for any application client.</li> <li>Receiving LiveKit webhook events.</li> </ul> <p>It internally uses the LiveKit Rust SDK.</p>"},{"location":"tutorials/application-server/rust/#running-this-tutorial","title":"Running this tutorial","text":""},{"location":"tutorials/application-server/rust/#1-run-livekit-server","title":"1. Run LiveKit Server","text":"<p>You can run LiveKit locally or you can use their free tier of LiveKit Cloud.</p> <p>Alternatively, you can use OpenVidu, which is a fully compatible LiveKit distribution designed specifically for on-premises environments. It brings notable improvements in terms of performance, observability and development experience. For more information, visit What is OpenVidu?.</p> Run OpenVidu locallyDeploy OpenViduRun LiveKit locallyUse LiveKit Cloud <ol> <li> <p>Download OpenVidu</p> <pre><code>git clone https://github.com/OpenVidu/openvidu-local-deployment\n</code></pre> </li> <li> <p>Configure the local deployment</p>  Windows macOS Linux <pre><code>cd openvidu-local-deployment/community\n.\\configure_lan_private_ip_windows.bat\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_macos.sh\n</code></pre> <pre><code>cd openvidu-local-deployment/community\n./configure_lan_private_ip_linux.sh\n</code></pre> </li> <li> <p>Run OpenVidu</p> <pre><code>docker compose up\n</code></pre> </li> </ol> <p>To use a production-ready OpenVidu deployment, visit the official OpenVidu deployment guide.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using a production deployment you need to configure webhooks to point to your local application server in order to make it work. Check the Send Webhooks to a Local Application Server section for more information.</p> <p>Follow the official instructions to run LiveKit locally.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit locally you need to configure webhooks to point to your application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Use your account in LiveKit Cloud.</p> <p>Configure Webhooks</p> <p>All application servers have an endpoint to receive webhooks from LiveKit. For this reason, when using LiveKit Cloud you need to configure webhooks to point to your local application server in order to make it work. Check the Webhooks section from the official documentation and follow the instructions to configure webhooks.</p> <p>Expose your local application server</p> <p>In order to receive webhooks from LiveKit Cloud on your local machine, you need to expose your local application server to the internet. Tools like Ngrok, LocalTunnel, LocalXpose and Zrok can help you achieve this. </p> <p>These tools provide you with a public URL that forwards requests to your local application server. You can use this URL to receive webhooks from LiveKit Cloud, configuring it as indicated above.</p>"},{"location":"tutorials/application-server/rust/#2-download-the-tutorial-code","title":"2. Download the tutorial code","text":"<pre><code>git clone https://github.com/OpenVidu/openvidu-livekit-tutorials.git\n</code></pre>"},{"location":"tutorials/application-server/rust/#3-run-the-server-application","title":"3. Run the server application","text":"<p>To run this server application, you need Rust installed on your device.</p> <ol> <li>Navigate into the server directory <pre><code>cd openvidu-livekit-tutorials/application-server/rust\n</code></pre></li> <li>Run the application <pre><code>cargo run\n</code></pre></li> </ol>"},{"location":"tutorials/application-server/rust/#4-run-a-client-application-to-test-against-this-server","title":"4. Run a client application to test against this server","text":"JavaScript React Angular Vue Electron Ionic Android iOS <p>To run the client application tutorial, you need an HTTP web server installed on your development computer. A great option is http-server. You can install it via NPM:</p> <pre><code>npm install -g http-server\n</code></pre> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-js\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>http-server -p 5080 ./src\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the JavaScript tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-react\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the React tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-angular\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Angular tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-vue\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Vue tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-electron\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Run the application:</p> <pre><code>npm start\n</code></pre> </li> </ol> <p>The application will seamlessly initiate as a native desktop program, adapting itself to the specific operating system you are using. Once the application is open, you should see a screen like this:</p> <p><p></p></p> <p><p></p></p> <p>Running your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates. For more information, see section Accessing your app from other devices in your network.</p> <p>For more information, check the Electron tutorial.</p> <p>To run the client application tutorial, you need Node.js installed on your development computer.</p> <ol> <li> <p>Navigate into the application client directory:</p> <pre><code>cd openvidu-livekit-tutorials/application-client/openvidu-ionic\n</code></pre> </li> <li> <p>Install the required dependencies:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Serve the application:</p> <p>You have two options for running the client application: browser-based or mobile device-based:</p>  Browser Mobile <p>To run the application in a browser, you will need to start the Ionic server. To do so, run the following command:</p> <pre><code>npm start\n</code></pre> <p>Once the server is up and running, you can test the application by visiting <code>http://localhost:5080</code>. You should see a screen like this:</p> <p>Mobile appearance</p> <p>To show the app with a mobile device appearance, open the dev tools in your browser and find the button to adapt the viewport to a mobile device aspect ratio. You may also choose predefined types of devices to see the behavior of your app in different resolutions.</p> <p><p></p></p> <p><p></p></p> <p>Accessing your application client from other devices in your local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client with other devices in your local network very easily without worrying about SSL certificates.</p> <p>Access your application client through <code>https://xxx-yyy-zzz-www.openvidu-local.dev:5443</code>, where <code>xxx-yyy-zzz-www</code> part of the domain is your LAN private IP address with dashes (-) instead of dots (.). For more information, see section Accessing your app from other devices in your network.</p> <p>Running the tutorial on a mobile device presents additional challenges compared to running it in a browser, mainly due to the application being launched on a different device, such as an Android smartphone or iPhone, rather than our computer. To overcome these challenges, the following steps need to be taken:</p> <ol> <li> <p>Localhost limitations:</p> <p>The usage of <code>localhost</code> in our Ionic app is restricted, preventing seamless communication between the application client and the server.</p> </li> <li> <p>Serve over local network:</p> <p>The application must be served over our local network to enable communication between the device and the server.</p> </li> <li> <p>Secure connection requirement for WebRTC API:</p> <p>The WebRTC API demands a secure connection for functionality outside of localhost, necessitating the serving of the application over HTTPS.</p> </li> </ol> <p>If you run OpenVidu locally you don't need to worry about this. OpenVidu will handle all of the above requirements for you. For more information, see section Accessing your app from other devices in your network.</p> <p>Now, let's explore how to run the application on a mobile device:</p> <p>Requirements</p> <p>Before running the application on a mobile device, make sure that the device is connected to the same network as your PC and the mobile is connected to the PC via USB or Wi-Fi.</p>  Android device iOS device <pre><code>npm run android\n</code></pre> <p>You will need Ruby and Cocoapods installed in your computer.</p> <p>The app must be signed with a development team. To do so, open the project in Xcode and select a development team in the Signing &amp; Capabilities editor.</p> <pre><code>npm run ios\n</code></pre> <p>The script will ask you for the device you want to run the application on. You should select the real device you have connected to your computer.</p> <p>Once the mobile device has been selected, the script will launch the application on the device and you will see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> </li> </ol> <p>For more information, check the Ionic tutorial.</p> <p>To run the client application tutorial, you need Android Studio installed on your development computer.</p> <ol> <li> <p>Open Android Studio and import the project located at <code>openvidu-livekit-tutorials/application-client/openvidu-android</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking the \"Run\" button in Android Studio. Check out the official documentation for further information.</p> </li> </ol> <p>The application will initiate as a native Android program. Once the application is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real Android device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real Android device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the Android tutorial.</p> <p>To run the client application tutorial, you need Xcode installed on your MacOS.</p> <ol> <li> <p>Launch Xcode and open the <code>OpenViduIOS.xcodeproj</code> that you can find under <code>openvidu-livekit-tutorials/application-client/openvidu-ios</code>.</p> </li> <li> <p>Run the application in an emulator or a physical device by clicking on the menu Product &gt; Run or by \u2318R.</p> </li> </ol> <p>Emulator limitations</p> <p>Publishing the camera track is not supported by iOS Simulator.</p> <p>If you encounter code signing issues, make sure you change the Team and bundle id from the previous step.</p> <p>The application will initiate as a native iOS application. Once the app is opened, you should see a screen like this:</p> <p><p></p></p> <p>This screen allows you to configure the URLs of the application server and the LiveKit server. You need to set them up for requesting tokens to your application server and connecting to the LiveKit server.</p> <p>Connecting real iOS device to application server running in you local network</p> <p>One advantage of running OpenVidu locally is that you can test your application client in a real iOS device and be able to reach the application server very easily without worrying about SSL certificates if they are both running in the same local network. For more information, see section Accessing your app from other devices in your network.</p> <p>Once you have configured the URLs, you can join a video call room by providing a room name and a user name. After joining the room, you will be able to see your own video and audio tracks, as well as the video and audio tracks of the other participants in the room.</p> <p><p></p></p> <p><p></p></p> <p>For more information, check the iOS tutorial.</p>"},{"location":"tutorials/application-server/rust/#understanding-the-code","title":"Understanding the code","text":"<p>The application is a simple Rust app with a single file <code>main.rs</code> that exports two endpoints:</p> <ul> <li><code>/token</code> : generate a token for a given Room name and Participant name.</li> <li><code>/livekit/webhook</code> : receive LiveKit webhook events.</li> </ul> <p>Let's see the code of the <code>main.rs</code> file:</p> main.rs<pre><code>use axum::http::HeaderMap;\nuse axum::{\n    extract::Json, http::header::CONTENT_TYPE, http::Method, http::StatusCode, routing::post,\n    Router,\n};\nuse dotenv::dotenv;\nuse livekit_api::access_token::AccessToken; // (1)!\nuse livekit_api::access_token::TokenVerifier;\nuse livekit_api::access_token::VideoGrants;\nuse livekit_api::webhooks::WebhookReceiver;\nuse serde_json::{json, Value};\nuse std::env;\nuse tokio::net::TcpListener;\nuse tower_http::cors::{Any, CorsLayer};\n\n#[tokio::main]\nasync fn main() {\n    dotenv().ok(); // (2)!\n\n    let server_port = env::var(\"SERVER_PORT\").unwrap_or(\"6081\".to_string());\n\n    let cors = CorsLayer::new() // (3)!\n        .allow_methods([Method::POST])\n        .allow_origin(Any)\n        .allow_headers([CONTENT_TYPE]);\n\n    let app = Router::new() // (4)!\n        .route(\"/token\", post(create_token))\n        .route(\"/livekit/webhook\", post(receive_webhook))\n        .layer(cors);\n\n    let listener = tokio::net::TcpListener::bind(\"0.0.0.0:\".to_string() + &amp;server_port)\n        .await\n        .unwrap();\n    axum::serve(listener, app).await.unwrap(); // (5)!\n}\n</code></pre> <ol> <li>Import all necessary dependencies from the Rust LiveKit library.</li> <li>Load environment variables from <code>.env</code> file.</li> <li>Enable CORS support.</li> <li>Define <code>/token</code> and <code>/livekit/webhook</code> endpoints.</li> <li>Start the server listening on the specified port.</li> </ol> <p>The <code>main.rs</code> file imports the required dependencies and loads the necessary environment variables:</p> <ul> <li><code>SERVER_PORT</code>: the port where the application will be listening.</li> <li><code>LIVEKIT_API_KEY</code>: the API key of LiveKit Server.</li> <li><code>LIVEKIT_API_SECRET</code>: the API secret of LiveKit Server.</li> </ul> <p>Then CORS support is enabled and the endpoints are defined. Finally the <code>axum</code> application is initialized on the specified port.</p>"},{"location":"tutorials/application-server/rust/#create-token-endpoint","title":"Create token endpoint","text":"<p>The endpoint <code>/token</code> accepts <code>POST</code> requests with a payload of type <code>application/json</code>, containing the following fields:</p> <ul> <li><code>roomName</code>: the name of the Room where the user wants to connect.</li> <li><code>participantName</code>: the name of the participant that wants to connect to the Room.</li> </ul> main.rs<pre><code>async fn create_token(payload: Option&lt;Json&lt;Value&gt;&gt;) -&gt; (StatusCode, Json&lt;Value&gt;) {\n    if let Some(payload) = payload {\n        let livekit_api_key = env::var(\"LIVEKIT_API_KEY\").unwrap_or(\"devkey\".to_string());\n        let livekit_api_secret = env::var(\"LIVEKIT_API_SECRET\").unwrap_or(\"secret\".to_string());\n\n        let room_name = match payload.get(\"roomName\") {\n            Some(value) =&gt; value,\n            None =&gt; {\n                return (\n                    StatusCode::BAD_REQUEST,\n                    Json(json!({ \"errorMessage\": \"roomName is required\" })),\n                );\n            }\n        };\n        let participant_name = match payload.get(\"participantName\") {\n            Some(value) =&gt; value,\n            None =&gt; {\n                return (\n                    StatusCode::BAD_REQUEST,\n                    Json(json!({ \"errorMessage\": \"participantName is required\" })),\n                );\n            }\n        };\n\n        let token = match AccessToken::with_api_key(&amp;livekit_api_key, &amp;livekit_api_secret) // (1)!\n            .with_identity(&amp;participant_name.to_string()) // (2)!\n            .with_name(&amp;participant_name.to_string())\n            .with_grants(VideoGrants { // (3)!\n                room_join: true,\n                room: room_name.to_string(),\n                ..Default::default()\n            })\n            .to_jwt() // (4)!\n        {\n            Ok(token) =&gt; token,\n            Err(_) =&gt; {\n                return (\n                    StatusCode::INTERNAL_SERVER_ERROR,\n                    Json(json!({ \"errorMessage\": \"Error creating token\" })),\n                );\n            }\n        };\n\n        return (StatusCode::OK, Json(json!({ \"token\": token }))); // (5)!\n    } else {\n        return (\n            StatusCode::BAD_REQUEST,\n            Json(json!({ \"errorMessage\": \"roomName and participantName are required\" })),\n        );\n    }\n}\n</code></pre> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol> <p>The endpoint first obtains the <code>roomName</code> and <code>participantName</code> parameters from the request body. If they are not available, it returns a <code>400</code> error.</p> <p>If required fields are available, a new JWT token is created. For that we use the LiveKit Rust SDK:</p> <ol> <li>A new <code>AccessToken</code> is created providing the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>.</li> <li>We set participant's name and identity in the AccessToken.</li> <li>We set the video grants in the AccessToken. <code>room_join</code> allows the user to join a room and <code>room</code> determines the specific room. Check out all Video Grants.</li> <li>We convert the AccessToken to a JWT token.</li> <li>Finally, the token is sent back to the client.</li> </ol>"},{"location":"tutorials/application-server/rust/#receive-webhook","title":"Receive webhook","text":"<p>The endpoint <code>/livekit/webhook</code> accepts <code>POST</code> requests with a payload of type <code>application/webhook+json</code>. This is the endpoint where LiveKit Server will send webhook events.</p> main.rs<pre><code>async fn receive_webhook(headers: HeaderMap, body: String) -&gt; (StatusCode, String) {\n    let livekit_api_key = env::var(\"LIVEKIT_API_KEY\").unwrap_or(\"devkey\".to_string());\n    let livekit_api_secret = env::var(\"LIVEKIT_API_SECRET\").unwrap_or(\"secret\".to_string());\n    let token_verifier = TokenVerifier::with_api_key(&amp;livekit_api_key, &amp;livekit_api_secret); // (1)!\n    let webhook_receiver = WebhookReceiver::new(token_verifier); // (2)!\n\n    let auth_header = match headers.get(\"Authorization\") { // (3)!\n        Some(header_value) =&gt; match header_value.to_str() {\n            Ok(header_str) =&gt; header_str,\n            Err(_) =&gt; {\n                return (\n                    StatusCode::BAD_REQUEST,\n                    \"Invalid Authorization header format\".to_string(),\n                );\n            }\n        },\n        None =&gt; {\n            return (\n                StatusCode::BAD_REQUEST,\n                \"Authorization header is required\".to_string(),\n            );\n        }\n    };\n\n    match webhook_receiver.receive(&amp;body, auth_header) { // (4)!\n        Ok(event) =&gt; {\n            println!(\"LiveKit WebHook: {:?}\", event); // (5)!\n            return (StatusCode::OK, \"ok\".to_string());\n        }\n        Err(_) =&gt; {\n            return (\n                StatusCode::UNAUTHORIZED,\n                \"Error validating webhook event\".to_string(),\n            );\n        }\n    }\n}\n</code></pre> <ol> <li>Create a <code>TokenVerifier</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This will validate the webhook event to confirm it is actually coming from our LiveKit Server.</li> <li>Create a <code>WebhookReceiver</code> with the <code>TokenVerifier</code>.</li> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw string body of the request and the <code>Authorization</code> header.</li> <li>Consume the event as you wish.</li> </ol> <p>We declare as function parameters the map of headers (<code>headers: HeaderMap</code>) and the raw body (<code>body: String</code>) of the HTTP request. We will need both of them to validate and decode the incoming webhook event. We then:</p> <ol> <li>Create a <code>TokenVerifier</code> with the <code>LIVEKIT_API_KEY</code> and <code>LIVEKIT_API_SECRET</code>. This will validate the webhook event to confirm it is actually coming from our LiveKit Server.</li> <li>Create a <code>WebhookReceiver</code> with the <code>TokenVerifier</code>.</li> <li>Get the <code>Authorization</code> header from the HTTP request.</li> <li>Obtain the webhook event using the <code>WebhookReceiver#receive</code> method. It expects the raw string body of the request and the <code>Authorization</code> header.</li> <li>Consume the event as you wish (in this case, we just log it).</li> </ol> <p>Remember to return a <code>200</code> OK response at the end to let LiveKit Server know that the webhook was received correctly.</p> <p>Configure Webhooks</p> <p>If you are using a production deployment, remember to configure the webhook URL to point to your local application server as explained in the Send Webhooks to a Local Application Server section.</p> <p></p>"}]}